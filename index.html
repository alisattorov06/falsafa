<!DOCTYPE html>
<html lang="uz">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My test</title>
    <link rel="icon" href="https://cdn-icons-png.flaticon.com/512/2936/2936886.png" type="image/x-icon">
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 0;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            flex-direction: column;
            transition: background-color 0.5s ease, color 0.5s ease;
            position: relative;
            background-color: #f5f5f5;
        }

        .dark-mode {
            background-color: #121212;
            color: #e0e0e0;
        }

        .dark-mode .container {
            background-color: #1e1e1e;
            color: #e0e0e0;
        }

        .dark-mode .question {
            color: #e0e0e0;
        }

        .dark-mode .options label {
            background-color: #2d2d2d;
            color: #e0e0e0;
        }

        .dark-mode .options label:hover {
            background-color: #3d3d3d;
        }

        .container {
            width: 95%;
            max-width: 800px;
            background: #fff;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            text-align: center;
            margin: 20px 0;
            transition: all 0.3s ease;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 20px;
            color: #333;
            transition: color 0.3s ease;
        }

        #startBtn {
            background-color: #4CAF50;
            color: white;
            padding: 15px 30px;
            font-size: 18px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        #startBtn:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        #darkModeBtn {
            position: fixed;
            right: 20px;
            top: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            border: none;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #darkModeBtn:hover {
            transform: scale(1.1);
        }

        .question {
            font-size: 20px;
            margin-bottom: 25px;
            color: #333;
            font-weight: 500;
            line-height: 1.4;
            transition: color 0.3s ease;
        }

        .options {
            margin-bottom: 25px;
            text-align: left;
        }

        .options label {
            display: block;
            margin: 10px 0;
            padding: 12px 15px;
            font-size: 16px;
            border-radius: 8px;
            cursor: pointer;
            background-color: #f0f0f0;
            transition: all 0.3s ease;
            border: 1px solid #ddd;
        }

        .options label:hover {
            background-color: #e0e0e0;
        }

        .options input[type="radio"] {
            margin-right: 10px;
        }

        .correct {
            background-color: #4CAF50 !important;
            color: white !important;
            border-color: #4CAF50 !important;
        }

        .incorrect {
            background-color: #f44336 !important;
            color: white !important;
            border-color: #f44336 !important;
        }

        .btn {
            display: inline-block;
            padding: 12px 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            margin: 10px 5px;
            text-decoration: none;
        }

        .btn:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        .btn-restart {
            background-color: #FF9800;
        }

        .btn-restart:hover {
            background-color: #F57C00;
        }

        .timer-container {
            width: 100%;
            height: 8px;
            background-color: #e0e0e0;
            border-radius: 4px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .timer-bar {
            height: 100%;
            width: 100%;
            background-color: #4CAF50;
            transition: width 1s linear;
            border-radius: 4px;
        }

        .timer-text {
            font-size: 16px;
            margin-bottom: 10px;
            color: #666;
        }

        #result {
            font-size: 24px;
            text-align: center;
            margin: 20px 0;
            color: #333;
            font-weight: bold;
            transition: color 0.3s ease;
        }

        .progress {
            font-size: 18px;
            margin-bottom: 15px;
            color: #666;
        }

        .start-page {
            text-align: center;
            padding: 20px;
            max-width: 600px;
            width: 90%;
        }

        .start-page h1 {
            font-size: 32px;
            margin-bottom: 30px;
            color: #333;
        }

        .start-page p {
            font-size: 18px;
            color: #666;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        @media (max-width: 600px) {
            .container {
                padding: 15px;
                width: 95%;
            }
            
            .question {
                font-size: 18px;
            }
            
            .options label {
                padding: 10px 12px;
                font-size: 15px;
            }
            
            #darkModeBtn {
                width: 40px;
                height: 40px;
                font-size: 16px;
                right: 15px;
                top: 15px;
            }
            
            .start-page h1 {
                font-size: 26px;
            }
            
            .start-page p {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="start-page">
        <h1>My test</h1>
        <p>Testda har bir savolga 30 soniya vaqt beriladi. To'g'ri javob yashil, noto'g'ri javob qizil rangda ko'rsatiladi. Har 50 ta savoldan keyin natijangiz ko'rsatiladi.</p>
        <button id="startBtn" class="btn">Testni Boshlash</button>
    </div>

    <div class="container" id="testContainer" style="display: none;">
        <div class="timer-text">Qolgan vaqt: <span id="time">30</span> soniya</div>
        <div class="timer-container">
            <div class="timer-bar" id="timerBar"></div>
        </div>
        <div class="progress" id="progress">Savol: 1/50</div>
        <div class="question" id="questionText"></div>
        <div class="options" id="optionsContainer"></div>
        <div id="result"></div>
    </div>

    <button id="darkModeBtn" onclick="toggleDarkMode()">üåô</button>

    <script>
        // Dark mode
        let darkMode = localStorage.getItem('darkMode') === 'true';
        
        function toggleDarkMode() {
            darkMode = !darkMode;
            localStorage.setItem('darkMode', darkMode);
            updateDarkMode();
        }
        
        function updateDarkMode() {
            document.body.classList.toggle('dark-mode', darkMode);
            document.getElementById('darkModeBtn').textContent = darkMode ? '‚òÄÔ∏è' : 'üåô';
        }
        
        // Boshlang'ich dark mode holati
        updateDarkMode();
        
        // Test ma'lumotlari
        const fileContent = `Ma‚Äôlumotlar tuzilmasi nima?
# Ma‚Äôlumotlarni samarali saqlash va foydalanish usuli
Grafik interfeys asosida ishlaydi
Faqat tashqi qurilmalar uchun
Axborotni uzatish uchun aloqa protokoli

+++++
Abstrakt ma‚Äôlumotlar tuzilmasi nimani anglatadi?
# Foydalanuvchi ko‚Äòradigan, lekin ichki amalga oshirilishi yashirilgan model
Faqat ko‚Äòrinadigan fayl tizimi
Fizik xotiraning to‚Äòliq tavsifi
Axborotni chiqaruvchi qurilma

+++++
Massiv qanday tuzilma hisoblanadi?
# Ketma-ket joylashgan bir xil turdagi elementlar to‚Äòplami
Faqat grafik tuzilma
Tasodifiy elementlar ketma-ketligi
Axborotni bosma holda saqlovchi tuzilma

+++++
Stek qanday ishlaydi?
# Oxirgi kirgan birinchi chiqadi (LIFO)
Birinchi kirgan birinchi chiqadi (FIFO)
Elementlar faqat o‚Äòrtasidan chiqariladi
Faqat tasodifiy kirish orqali ishlaydi

+++++
Queue (navbat) qanday asosiy prinsipga ega?
# Birinchi kirgan birinchi chiqadi (FIFO)
Oxirgi kirgan birinchi chiqadi (LIFO)
Faqat indeks orqali chaqiriladi
Faqat juft sonlar uchun ishlaydi

+++++
Algoritm tahlilining asosiy maqsadi nima?
# Algoritmning samaradorligini baholash
Kod yozilish stilini aniqlash
Rasmiy dizaynni tasdiqlash
Foydalanuvchi interfeysini chizish

+++++
Asimptotik tahlilda O(n) nimani bildiradi?
# Vazifani bajarish vaqti kirish hajmiga proporsional
Vaqt o‚Äòzgarmas bo‚Äòladi
Foydalanilmaydigan algoritm
Faqat grafik chizmalar bilan bog‚Äòliq

+++++
Abstrakt tiplar misoliga qaysi biri kiradi?
# Stack (stek)
Tasma printer
Sensorli ekran
Uzatish kabeli

+++++
Ma‚Äôlumotlar tuzilmalarining ikkiga bo‚Äòlinishi nimani bildiradi?
# Statik va dinamik tuzilmalar
Sonli va matnli fayllar
Axborot va uskunalar
Kompyuter va telefon uchun

+++++
Rekursiv algoritm nima?
# O‚Äòzini o‚Äòzi chaqiruvchi algoritm
Faqat bitta amalni bajargan algoritm
Kodda sikl mavjud bo‚Äòlmagan algoritm
Tashqi qurilmasiz ishlaydigan algoritm

+++++
Ma‚Äôlumotlarning boshlang‚Äòich turi qanday bo‚Äòladi?
# Oddiy (primitive) turlar
Chuqur o‚Äòzaro bog‚Äòlangan modullar
Murakkab grafik komponentlar
Tarmoqli qurilma signallari

+++++
Ma‚Äôlumotlarni ifodalash bosqichlaridan biri nima?
# Kodlash
Siklga qo‚Äòyish
Sensorli chiqarish
Blok sxema chizish

+++++
Tartiblash algoritmlarining asosiy vazifasi nima?
# Elementlarni ma‚Äôlum tartibda joylashtirish
Xatoliklarni yashirish
Grafik interfeys yasash
Fayl tizimlarini o‚Äòchirish

+++++
Murakkablik darajasi O(1) bo‚Äòlgan operatsiya qanday?
# Doimiy vaqt talab qiladi
Foydalanuvchi kiritmasiga bog‚Äòliq
Fayl hajmiga qarab o‚Äòzgaradi
Faqat dinamik massivda ishlaydi

+++++
Ma‚Äôlumotlar tuzilmasining asosiy xususiyatlaridan biri nima?
# Ma‚Äôlumotlarga kirish tezligi
Grafik interfeys dizayni
Dastur tilining versiyasi
Tashqi xotira o‚Äòlchami
+++++
Rekursiv funksiyaning asosiy xususiyati nima?
# O‚Äòzini o‚Äòzi chaqiradi
Faqat tashqi funksiyalarni chaqiradi
Sikl bilan ishlaydi
Faqat massivlar bilan ishlaydi

+++++
Rekursiya qanday hollarda to‚Äòxtaydi?
# Bazaviy holatga yetganda
Fayl ochilganda
Massiv tugaganda
Xatolik chiqqanda

+++++
Fibonachchi sonlarini hisoblashda rekursiya qanday ishlatiladi?
# Har bir son avvalgi ikki son yig‚Äòindisi sifatida chaqiriladi
Faqat toq sonlar olinadi
Har safar 1 ga kamaytiriladi
Natija faqat 0 bo‚Äòladi

+++++
Rekursiv algoritmda ‚Äúbazaviy holat‚Äù nima?
# Rekursiyani to‚Äòxtatish sharti
Natijani ekranga chiqarish holati
Dastur ishlamay qolishi
Sonlarni teskari aylantirish

+++++
Rekursiv funksiyaning kamchiligi nima bo‚Äòlishi mumkin?
# Stack overflow xatoligiga olib kelishi mumkin
Doim eng samarali bo‚Äòladi
Faqat Pythonda ishlaydi
Xotira talab qilmaydi

+++++
Faktorialni rekursiv hisoblashda qanday ifoda ishlatiladi?
# n * factorial(n - 1)
n + factorial(n)
n / factorial(n + 1)
n - 1 * factorial(n)

+++++
Rekursiv funksiyalar qanday tuzilmada saqlanadi?
# Stack (stek)
Queue (navbat)
Graf
Hash jadval

+++++
Rekursiyani iteratsiyaga nisbatan farqlovchi jihat nima?
# O‚Äòzini chaqirish orqali ishlashi
Faoliyatini foydalanuvchi belgilar
Faqat grafik muhitda ishlashi
To‚Äòliq kompilyatsiya talab etishi

+++++
Rekursiv algoritm samaradorligi nimaga bog‚Äòliq?
# Bazaviy holatga tez yetishga
Chuqurlikdagi massivlar soniga
Monitor ekraniga
Funksiya nomining uzunligiga

+++++
Tail-recursion nima?
# Oxirgi chaqiruv rekursiv bo‚Äòlgan funksiya
Faqat bitta parametrli funksiya
Massivni teskari o‚Äòqish
Funksiya chaqirilmasligi
+++++
Qidiruv algoritmining asosiy maqsadi nima?
# Kerakli elementni topish
Grafni chizish
Fayl hajmini kamaytirish
Xotirani formatlash

+++++
Chiziqli qidiruv qanday ishlaydi?
# Elementlarni boshidan oxirigacha tekshiradi
Massivni ikkiga bo‚Äòladi
Faqat juft indeksli elementlarni qidiradi
Faqat oxirgi elementni tekshiradi

+++++
Binar qidiruv uchun qanday shart kerak?
# Massiv oldindan saralangan bo‚Äòlishi kerak
Elementlar unikal bo‚Äòlishi kerak
Faqat matnli ma‚Äôlumotlar bo‚Äòlishi kerak
Massiv teskari tartibda bo‚Äòlishi kerak

+++++
Binar qidiruv qanday ishlaydi?
# Har safar massivni ikkiga bo‚Äòlib, kerakli qismini tekshiradi
Barcha elementlarni ketma-ket tekshiradi
Faqat oxirgi uchta elementni solishtiradi
Massivni aralashtirib yuboradi

+++++
Chiziqli qidiruvning yomon holatdagi murakkabligi qanday?
# O(n)
O(1)
O(log n)
O(n log n)

+++++
Binar qidiruvning eng yaxshi holatdagi murakkabligi qanday?
# O(1)
O(n)
O(n^2)
O(n!)

+++++
Binar qidiruvda element topilmasa nima bo‚Äòladi?
# Qidiruv davom etadi va oxirida topilmadi deb qaytaradi
Topilmagan element avtomatik qo‚Äòshiladi
Qidiruv boshlanishiga qaytadi
Barcha elementlar o‚Äòchiriladi

+++++
Chiziqli qidiruvda birinchi topilgan element bilan nima qilinadi?
# Qidiruv to‚Äòxtaydi
Keyingi elementga o‚Äòtiladi
Massiv teskari aylanadi
Yangi element qo‚Äòshiladi

+++++
Binar qidiruv algoritmi uchun massiv qanday bo‚Äòlishi kerak?
# Saralangan
Noto‚Äòg‚Äòri tartiblangan
Faqat bitta elementdan iborat
Null qiymatlardan iborat

+++++
Qidiruv algoritmlari qaysi sohalarda qo‚Äòllaniladi?
# Ma‚Äôlumotlar bazasi, qidiruv tizimlari
Faqat grafik chizishda
Foydalanuvchi interfeysda
Qurilma drayverlarida

+++++
Qidiruv algoritmlarining samaradorligi nimaga bog‚Äòliq?
# Elementlar soni va ma‚Äôlumotlar tartibiga
Foydalanuvchi kompyuteri ekraniga
Sensorlar holatiga
Tashqi qurilma brendiga

+++++
Binar qidiruv natijasi topilsa nima qaytaradi?
# Elementning indeksi
Elementning matni
Null qiymat
Butun massiv

+++++
Chiziqli qidiruvda element mavjud bo‚Äòlmasa nima bo‚Äòladi?
# Butun massiv tekshiriladi va -1 qaytariladi
Xatolik chiqariladi
Biror qiymat avtomatik tanlanadi
Massiv saralanadi

+++++
Qidiruv algoritmlarini optimallashtirishning usuli qanday?
# Ma‚Äôlumotlarni oldindan saralash
Har bir elementni ikki marta tekshirish
Tasodifiy indeks tanlash
Xotirani tozalash

+++++
Interpolatsion qidiruv qachon samaraliroq?
# Ma‚Äôlumotlar bir tekisda taqsimlangan bo‚Äòlsa
Ma‚Äôlumotlar kichik bo‚Äòlsa
Faqat matn bo‚Äòlsa
Grafik bo‚Äòlsa
+++++
Xeshlash algoritmining asosiy vazifasi nima?
# Ma‚Äôlumotni unikal kalitga aylantirish
Ma‚Äôlumotni grafik ko‚Äòrinishga o‚Äòtkazish
Ma‚Äôlumotni avtomatik o‚Äòchirish
Ma‚Äôlumotni ekranda aks ettirish

+++++
Xesh jadval nima?
# Kalit-qiymat juftliklarini saqlovchi ma‚Äôlumotlar tuzilmasi
Faqat massivdan iborat tuzilma
Ikki o‚Äòlchamli grafik fayl
Matnli fayl tuzilmasi

+++++
Xesh funksiyasi qanday ishlaydi?
# Kiruvchi qiymatni ma‚Äôlum indeksga moslab beradi
Ma‚Äôlumotni ketma-ket qidiradi
Elementlarni teskari o‚Äògiradi
Massivni saralaydi

+++++
Xesh to‚Äòqnashuvi (collision) deganda nima tushuniladi?
# Ikkita qiymat bir xil xesh indeksga ega bo‚Äòlishi
Massiv elementlari teskari bo‚Äòlishi
Faylning yo‚Äòqolib qolishi
Grafik interfeys noto‚Äòg‚Äòri chizilishi

+++++
Xesh to‚Äòqnashuvlarini hal qilish usullaridan biri bu:
# Zanjirli bog‚Äòlash (chaining)
Rekursiv tozalash
Kompressiyalash
Matnni kodlash

+++++
Ochiq adresatsiyalash usuli nima?
# Bo‚Äòsh joy topilguncha indeksni ko‚Äòchirish
Massivni to‚Äòliq qayta qurish
Elementni o‚Äòchirish
Grafni bog‚Äòlash

+++++
Xesh funksiyalar qaysi algoritmlarda keng qo‚Äòllaniladi?
# Parollarni saqlashda
Grafik chizishda
Multimedia fayllarda
Sensorli ekranlarda

+++++
Xesh funksiyaning yaxshi bo‚Äòlishi uchun nima kerak?
# To‚Äòqnashuv ehtimolini kamaytirishi kerak
Faqat tasodifiy sonlar hosil qilishi
Faqat harflar bilan ishlashi
Doim 0 natija qaytarishi

+++++
Xesh jadvaldagi indekslar qanday aniqlanadi?
# Xesh funksiyasi orqali
Tasodifiy tanlanadi
Raqamlarni qiyoslab
Graf bo‚Äòyicha

+++++
Ma‚Äôlumotlar bazasida xesh funksiyalari nima uchun kerak?
# Tezroq qidirish va taqqoslash uchun
Fayl nomini o‚Äòzgartirish uchun
Rasm yuklash uchun
Ma‚Äôlumotlarni tahrirlash uchun

+++++
Xesh jadvalning asosiy ustunligi nima?
# Qidiruv va qo‚Äòshish tezligi yuqori bo‚Äòladi
Xotirani tozalab turadi
Grafik interfeysni boshqaradi
Tasodifiy indeks yaratadi

+++++
Xesh funksiyasi qanday kirishni qamrab oladi?
# Belgilar, raqamlar yoki matnlar
Faqat rasmlar
Faqat audio fayllar
Faqat video fayllar

+++++
Qaysi biri xesh to‚Äòqnashuvi yuz berishining sababi bo‚Äòlishi mumkin?
# Bir nechta kalitlar bir xil indeksga tushishi
Qidiruv noto‚Äòg‚Äòri bo‚Äòlishi
Massiv uzun bo‚Äòlishi
Fayl yo‚Äòq bo‚Äòlishi

+++++
Xesh jadvalda ma‚Äôlumotlar qanday saqlanadi?
# Kalit-qiymat (key-value) juftliklarida
Faqat sonlar shaklida
Ko‚Äòp o‚Äòlchamli massivda
Rasmlar ko‚Äòrinishida

+++++
Eng mashhur xesh algoritmlaridan biri bu:
# SHA-256
HTML5
PNG
SQL
+++++
Saralash algoritmining asosiy vazifasi nima?
# Ma‚Äôlumotlarni tartibga keltirish
Ma‚Äôlumotlarni o‚Äòchirish
Xotirani tozalash
Grafik chizish

+++++
Bubble Sort algoritmi qanday ishlaydi?
# Yondosh elementlarni taqqoslab almashtiradi
Faqat indekslarni o‚Äòzgartiradi
Elementlarni tasodifiy joylashtiradi
Faoliyatni rekursiyaga asoslaydi

+++++
Insertion Sort algoritmining yondashuvi qanday?
# Har bir elementni mos joyiga qo‚Äòyadi
Elementlarni teskari tartibga o‚Äòtkazadi
Faqat juft sonlarni saralaydi
Ma‚Äôlumotlarni o‚Äòchiradi

+++++
Selection Sort algoritmida nima amalga oshiriladi?
# Har safar eng kichik (yoki katta) element tanlanadi
Elementlar ikki baravar ortadi
Faqat juft indeksli qiymatlar o‚Äòzgaradi
Xesh qiymatlar hosil qilinadi

+++++
Quick Sort qanday tamoyil asosida ishlaydi?
# Bo‚Äòlish va hukmronlik (Divide and Conquer)
FIFO tartibi
Massivni ikki baravar uzunlashtirish
Stekka qo‚Äòshish orqali

+++++
Merge Sort algoritmining yondashuvi nima?
# Massivni ikkiga bo‚Äòlib, so‚Äòngra birlashtirish
Foydalanuvchi kiritgan qiymatlar asosida
Faqat matnli qiymatlarni saralash
Massivni to‚Äòg‚Äòridan-to‚Äòg‚Äòri teskari aylantirish

+++++
Bubble Sort algoritmining yomon holatdagi murakkabligi qanday?
# O(n^2)
O(1)
O(log n)
O(n log n)

+++++
Quick Sort algoritmining o‚Äòrtacha ishlash murakkabligi nima?
# O(n log n)
O(n^2)
O(2^n)
O(n!)

+++++
Saralash algoritmlarida "stabil" degani nimani anglatadi?
# Bir xil qiymatli elementlar joylashuvi saqlanib qoladi
Faqat toq sonlar saralanadi
Xotira sarfi doimiy bo‚Äòladi
Natija har doim teskari chiqadi

+++++
Qaysi algoritm rekursiv ishlaydi?
# Merge Sort
Selection Sort
Bubble Sort
Insertion Sort

+++++
Saralash algoritmini tanlashda eng muhim omil nima?
# Ma‚Äôlumot hajmi va tartibi
Foydalanuvchi ismi
Rasm formati
Dastur nomi

+++++
Hech qanday qo‚Äòshimcha xotira talab qilmaydigan saralash turi bu:
# In-place sort
Out-of-core sort
Grafik sort
Xesh sort

+++++
Saralash algoritmlari qaysi sohalarda qo‚Äòllaniladi?
# Ma‚Äôlumotlar bazasi, qidiruv tizimlari, grafikalar
Faqat brauzer sozlamalarida
Tarmoq simlarini ulanganda
Kompyuter ekranini tozalaganda

+++++
Heap Sort algoritmi qanday tuzilma asosida ishlaydi?
# Ikkilik heap daraxt
Massivlar tarmog‚Äòi
Xesh jadval
Graf ko‚Äòrinishi

+++++
Quick Sort algoritmining eng yomon holatdagi murakkabligi qanday?
# O(n^2)
O(n log n)
O(1)
O(log n)
+++++
Statik massivning asosiy xususiyati nima?
# O‚Äòlchami dastlab belgilangan va o‚Äòzgarmaydi
O‚Äòlchami har doim oshadi
Elementlari faqat raqamlar bo‚Äòladi
Har doim teskari tartibda saqlanadi

+++++
Dinamik massivning asosiy afzalligi nima?
# O‚Äòlchami dastur davomida o‚Äòzgarishi mumkin
Elementlar teskari saqlanadi
Faqat matnli qiymatlarni oladi
Xotirani faqat boshlang‚Äòich qiymatlarda egallaydi

+++++
Chiziqli bog‚Äòlangan ro‚Äòyhat nima?
# Elementlar pointerlar orqali ketma-ket bog‚Äòlangan tuzilma
Massivdagi elementlarning aralash joylashuvi
Tasodifiy fayl ochish usuli
Grafik ko‚Äòrinishda jadval

+++++
Bir bog‚Äòlamli ro‚Äòyhatda har bir tugun qanday bog‚Äòlanadi?
# Keyingi tugunga pointer orqali
Oldingi tugunga pointer orqali
Bosh tugunga bog‚Äòlanadi
Tasodifiy joyga

+++++
Ikki bog‚Äòlamli ro‚Äòyhatda har bir tugun nechta pointerga ega?
# Ikki ‚Äî oldingi va keyingi tugunlarga
Faqat bittaga
Uchta pointer
Pointerlar yo‚Äòq

+++++
Statik massivga yangi element qo‚Äòshish mumkinmi?
# Yo‚Äòq, o‚Äòlchami qat‚Äôiy
Ha, doim mumkin
Faqat boshida qo‚Äòshish mumkin
Faqat oxirida qo‚Äòshish mumkin

+++++
Dinamik massivda elementni qanday qo‚Äòshish mumkin?
# O‚Äòlchamni o‚Äòzgartirib yangi element joylash
Faqat o‚Äòchirib, qayta yaratish
Faqat o‚Äòlcham kamaytirish mumkin
Elementlar joyi o‚Äòzgarmaydi

+++++
Chiziqli bog‚Äòlangan ro‚Äòyhatda element qidirish qanday amalga oshadi?
# Tugunlarni ketma-ket tekshirish orqali
Indeks bo‚Äòyicha to‚Äòg‚Äòridan-to‚Äòg‚Äòri kirish
Tasodifiy qidiruv
Massivdan foydalanish orqali

+++++
Bir bog‚Äòlamli ro‚Äòyhatda elementni qanday qo‚Äòshish mumkin?
# Pointerni mos ravishda yangilash orqali
Massivga qo‚Äòshish bilan bir xil
Elementlarni teskari tartibda almashtirish bilan
Yangi ro‚Äòyhat yaratish bilan

+++++
Ikki bog‚Äòlamli ro‚Äòyhatda elementni o‚Äòchirishda nimaga e‚Äôtibor beriladi?
# Oldingi va keyingi pointerlarni to‚Äòg‚Äòri bog‚Äòlash
Faqat keyingi pointer yangilanadi
Faqat oldingi pointer yangilanadi
Pointerlar o‚Äòchirilmaydi

+++++
Statik va dinamik massiv orasidagi asosiy farq nima?
# O‚Äòlcham o‚Äòzgartirilishi mumkin yoki yo‚Äòqligi
Ma‚Äôlumot turi
Massiv elementlari soni
Massiv nomi

+++++
Chiziqli bog‚Äòlangan ro‚Äòyhatni yaratishda qaysi operatsiya bajariladi?
# Tugunlar uchun xotira ajratish
Elementlarni saralash
Elementlarni nusxalash
Massivni tartiblash

+++++
Bir bog‚Äòlamli ro‚Äòyhatda oxirgi tugunni topish uchun nima qilish kerak?
# Boshidan ketma-ket tugunlarni o‚Äòtkazish
Oxiridan boshlab qidirish
Tasodifiy element tanlash
Faqat indeks yordamida

+++++
Ikki bog‚Äòlamli ro‚Äòyhat qaysi holatlarda afzal?
# Oldingi va keyingi elementlarga tez kira olish uchun
Faqat oddiy qidiruvda
Elementlarni massivda saqlash uchun
Elementlarni grafik ko‚Äòrinishda

+++++
Dinamik massiv qanday ma‚Äôlumotlarni saqlashda qulay?
# O‚Äòlchami o‚Äòzgaruvchi ma‚Äôlumotlar uchun
Faqat matnlar uchun
Faqat raqamlar uchun
Faqat bitta element uchun

+++++
Chiziqli bog‚Äòlangan ro‚Äòyhatda yangi elementni boshiga qo‚Äòshish uchun nimani o‚Äòzgartirish kerak?
# Bosh pointer va yangi tugun pointerini
Faqat oxirgi tugunni
Hech narsa o‚Äòzgarmaydi
Massiv o‚Äòlchamini

+++++
Bir bog‚Äòlamli ro‚Äòyhatning kamchiligi nima?
# Orqaga qaytish qiyinligi
Tezkor qidiruv imkoniyati
Doim o‚Äòzgaruvchan o‚Äòlcham
Xotirani ko‚Äòp ishlatish

+++++
Ikki bog‚Äòlamli ro‚Äòyhatda yangi elementni qo‚Äòshish qiyinligi nimada?
# Oldingi va keyingi pointerlarni to‚Äòg‚Äòri bog‚Äòlash
Faqat yangi tugunni yaratish
Massivni yangilash
Grafni chizish

+++++
Statik massiv qanday xotira taqsimotini talab qiladi?
# Ketma-ket bloklar
Tasodifiy bloklar
Pointerlar to‚Äòplami
Ikki o‚Äòlchamli massiv

+++++
Dinamik massivda bo‚Äòsh joy yetarli bo‚Äòlmasa nima qilinadi?
# Yangi katta joy ajratilib, elementlar ko‚Äòchiriladi
Elementlar o‚Äòchiriladi
Elementlar teskari tartibda joylashtiriladi
Programma xatolik chiqaradi
+++++
Navbat (Queue) nima?
# Birinchi kirgan, birinchi chiqadi (FIFO) prinsipi asosida ishlaydi
Oxirgi kirgan, birinchi chiqadi (LIFO)
Tasodifiy tartibda ishlaydi
Elementlarni doim o‚Äòchiradi

+++++
Stek (Stack) qanday printsipda ishlaydi?
# Oxirgi kirgan, birinchi chiqadi (LIFO)
Birinchi kirgan, birinchi chiqadi (FIFO)
Tasodifiy kirish
Elementlarni teskari tartibda chiqaradi

+++++
Dek (Deque) ma‚Äôlumotlar tuzilmasining xususiyati nima?
# Elementlarni ikkala tomondan qo‚Äòshish va o‚Äòchirish mumkin
Faqat oxiridan qo‚Äòshish mumkin
Faqat boshidan o‚Äòchirish mumkin
Faqat bitta element saqlaydi

+++++
Navbatni massiv yordamida tasvirlashda indekslar qanday ishlaydi?
# Kirish oxirgi indeksda, chiqish bosh indeksda amalga oshadi
Kiruvchi va chiquvchi indekslar bir xil
Faqat bitta indeks bor
Elementlar joyi o‚Äòzgarmaydi

+++++
Stekni massiv yordamida tasvirlashda asosiy operatsiya nima?
# Elementni oxirgi joyga qo‚Äòshish va olib tashlash
Elementlarni tasodifiy almashtirish
Elementlarni boshlang‚Äòich joyga qo‚Äòshish
Elementlarni o‚Äòchirib turish

+++++
Chiziqli bog‚Äòlangan ro‚Äòyhat yordamida navbat qanday tashkil qilinadi?
# Har bir tugun keyingi tugunga pointer orqali bog‚Äòlangan
Tugunlar teskari bog‚Äòlangan
Elementlar massivda saqlanadi
Xesh funktsiyasi bilan bog‚Äòlanadi

+++++
Stekda yangi elementni qo‚Äòshish operatsiyasi nima deb ataladi?
# Push
Pop
Enqueue
Dequeue

+++++
Stekdan elementni chiqarish operatsiyasi nima deb ataladi?
# Pop
Push
Insert
Remove

+++++
Navbatda element qo‚Äòshish operatsiyasi qanday ataladi?
# Enqueue
Push
Pop
Delete

+++++
Navbatdan element chiqarish operatsiyasi qanday ataladi?
# Dequeue
Pop
Push
Insert

+++++
Dek tuzilmasida element qo‚Äòshishning nechta varianti bor?
# Ikkita ‚Äî boshidan va oxiridan
Faqat bitta ‚Äî boshidan
Faqat bitta ‚Äî oxiridan
Uchta

+++++
Chiziqli bog‚Äòlangan ro‚Äòyhat yordamida stekni yaratishda qaysi tugun qo‚Äòshiladi?
# Boshiga yangi tugun
Oxiriga yangi tugun
Tasodifiy joyga
Xesh jadvalga

+++++
Massiv yordamida navbatda o‚Äòchirish operatsiyasining murakkabligi qanday?
# O(1)
O(n)
O(log n)
O(n log n)

+++++
Massiv yordamida stekda qo‚Äòshish va o‚Äòchirish operatsiyalarining murakkabligi nima?
# O(1)
O(n)
O(log n)
O(n^2)

+++++
Dekni chiziqli bog‚Äòlangan ro‚Äòyhat yordamida ifodalashda nima qo‚Äòshiladi?
# Har bir tugunga oldingi va keyingi pointerlar
Faqat keyingi pointerlar
Faqat oldingi pointerlar
Pointerlar yo‚Äòq

+++++
Navbat va stek orasidagi asosiy farq nima?
# Navbat FIFO, stek LIFO printsipida ishlaydi
Navbat elementlarni o‚Äòchiradi, stek esa qo‚Äòshadi
Ikkalasi ham faqat massivda ishlaydi
Ikkalasi ham faqat bog‚Äòlangan ro‚Äòyhatda ishlaydi

+++++
Stek va navbatni qaysi sohada ko‚Äòp qo‚Äòllaniladi?
# Algoritmlarda va operatsion tizimlarda
Faqat grafikalar uchun
Matematikada emas
Faqat fayl tizimida

+++++
Massiv yordamida navbatning asosiy kamchiligi nima?
# Bo‚Äòsh joydan unumli foydalanmasligi
Elementlarni teskari joylashishi
Ma‚Äôlumotlarni o‚Äòchirish qiyinligi
Pointerlar yo‚Äòqligi

+++++
Chiziqli bog‚Äòlangan ro‚Äòyhat yordamida stek yaratish afzalligi nima?
# Dinamik xotira ishlatish va o‚Äòlchamini o‚Äòzgartirish imkoniyati
Massivlar bilan taqqoslaganda tezligi past
Faqat matnli ma‚Äôlumotlar uchun
Faqat grafikalar uchun
+++++
Ustivor navbat (Priority Queue) qanday ishlaydi?
# Har doim eng yuqori ustivorga ega element birinchi olinadi
FIFO printsipida ishlaydi
LIFO printsipida ishlaydi
Elementlar tasodifiy olinadi

+++++
Navbat va ustivor navbat orasidagi farq nima?
# Ustivor navbatda elementlar ustivorga ko‚Äòra chiqariladi
Navbatda elementlar tasodifiy olinadi
Navbat LIFO, ustivor FIFO printsipida ishlaydi
Ustivor navbat faqat matnli ma‚Äôlumotlarni saqlaydi

+++++
Lug‚Äòat (Dictionary) nima?
# Kalit-qiymat juftliklarini saqlovchi ma‚Äôlumotlar tuzilmasi
Faqat raqamlarni saqlaydi
Faqat ketma-ket massivdir
Faqat xesh funktsiyasidan iborat

+++++
Lug‚Äòatni qanday ma‚Äôlumotlar tuzilmasi yordamida amalga oshirish mumkin?
# Hash jadval yordamida
Massivning boshida
Chiziqli bog‚Äòlangan ro‚Äòyhatda
Ikki bog‚Äòlamli ro‚Äòyhatda

+++++
Chiziqli konteynerlar qaysilar?
# Ro‚Äòyhat, stek, navbat va dek
Graf, daraxt, xesh jadval
Fayl tizimi, operatsion tizim
HTML va CSS

+++++
Iterator nima?
# Ma‚Äôlumotlar tuzilmasidagi elementlarga ketma-ket kirishni ta‚Äôminlovchi obyekt
Yangi ma‚Äôlumot qo‚Äòshuvchi funksiyalar
Elementlarni o‚Äòchiruvchi algoritm
Ma‚Äôlumotlarni saralovchi qism

+++++
Iteratorning asosiy vazifasi nima?
# Ma‚Äôlumotlar tuzilmasida harakatlanish
Yangi ma‚Äôlumot yaratish
Foydalanuvchi interfeysini yaratish
Xotirani boshqarish

+++++
Ustivor navbatda element qo‚Äòshish operatsiyasi qanday nomlanadi?
# Insert yoki Enqueue with priority
Push
Pop
Dequeue

+++++
Iteratorlarning qaysi turi elementlarga faqat oldinga qarab harakatlanadi?
# Forward iterator
Bidirectional iterator
Random access iterator
Reverse iterator

+++++
Random access iterator qaysi ma‚Äôlumotlar tuzilmasida keng qo‚Äòllanadi?
# Massiv va vektor kabi kontynerlarda
Bog‚Äòlangan ro‚Äòyhatda
Hash jadvalda
Fayllarda

+++++
Stek, navbat va dek qanday chiziqli konteynerlardir?
# Ma‚Äôlumotlar ketma-ketligi bilan ishlaydi
Grafga o‚Äòxshash
Daraxtlar bilan ishlaydi
Tasodifiy ma‚Äôlumotlarni saqlaydi

+++++
Ustivor navbatni amalga oshirish uchun qaysi tuzilma ko‚Äòpincha ishlatiladi?
# Ikkilik heap (binary heap)
Ikkilik daraxt
Chiziqli ro‚Äòyhat
Matritsa

+++++
Lug‚Äòatda kalit bo‚Äòyicha qiymat qidirish qanday murakkablikda bo‚Äòladi?
# O(1) (hash jadvalda)
O(n^2)
O(log n)
O(n)

+++++
Dekda element qo‚Äòshish va o‚Äòchirish operatsiyalari qayerdan amalga oshirilishi mumkin?
# Ikkala tomonidan ham
Faqat boshidan
Faqat oxiridan
Faqat o‚Äòrtadan

+++++
Iteratorning bidirectional turi nimani ta‚Äôminlaydi?
# Oldinga va orqaga harakatlanishni
Faqat oldinga harakatlanishni
Faqat tasodifiy kirishni
Faqat orqaga harakatlanishni

+++++
Iteratorlar qaysi dasturlash tillarida keng qo‚Äòllaniladi?
# C++, Java, Python va boshqalar
Faqat C tilida
Faqat HTMLda
Faqat SQLda

+++++
Navbatni chiziqli bog‚Äòlangan ro‚Äòyhat yordamida amalga oshirishda qanday ko‚Äòrsatkichlar kerak?
# Bosh va oxir ko‚Äòrsatkichlari
Faqat bosh ko‚Äòrsatkich
Faqat oxir ko‚Äòrsatkich
Ko‚Äòrsatkichlar kerak emas

+++++
Stekda eng oxirgi qo‚Äòshilgan elementni olish uchun qanday operatsiya ishlatiladi?
# Pop
Push
Enqueue
Dequeue

+++++
Lug‚Äòatdagi kalit topilmasa nima sodir bo‚Äòladi?
# Xatolik yoki null qiymat qaytariladi
Doim yangi kalit qo‚Äòshiladi
Qiymat avtomatik o‚Äòzgartiriladi
Hech narsa sodir bo‚Äòlmaydi

+++++
Iterator yordamida ma‚Äôlumotlar ustida qanday amallarni bajarish mumkin?
# Ko‚Äòrish, o‚Äòzgartirish, harakatlanish
Faqat o‚Äòchirish
Faqat qo‚Äòshish
Faqat yangi ro‚Äòyhat yaratish
+++++
Daraxt (Tree) ma‚Äôlumotlar tuzilmasi nima?
# Tugunlar (node) va ularning ota-ona (parent) va bolalar (child) munosabatlarini ifodalovchi ierarxik struktura
Faqat ketma-ket massiv
Faqat graflar yig‚Äòindisi
Faqat matnli ma‚Äôlumotlar ro‚Äòyxati

+++++
Daraxtda ildiz (root) tugun nima?
# Daraxtning eng yuqori darajadagi yagona tuguni
Har bir tugun uchun oxirgi bola
Faqat barg tugunlari
Tugunlar orasidagi bog‚Äòlanish

+++++
Daraxtda barg (leaf) tugun nima?
# Hech qanday bolasi bo‚Äòlmagan tugun
Har bir tugun uchun ota-ona
Faqat ildiz tugun
Faqat bitta bola bo‚Äòlgan tugun

+++++
Daraxtning chuqurligi nima?
# Ildizdan eng chuqur barggacha bo‚Äòlgan yo‚Äòl uzunligi
Faqat ildiz tugunning balandligi
Har bir tugun soni
Tugunlar orasidagi masofa

+++++
Binarny daraxt nima?
# Har bir tugunning eng ko‚Äòp ikkita bolasi bor
Har bir tugunning faqat bitta bolasi bor
Har bir tugun uchta bola bilan
Tugunlar ketma-ket massivda joylashgan

+++++
To‚Äòliq binarny daraxtda nechta bola bor?
# Har bir tugun 0 yoki 2 bolaga ega
Har bir tugun faqat bitta bola
Faqat ildiz tugun bola
Hech qanday bola yo‚Äòq

+++++
Daraxtda otaning darajasi nimani bildiradi?
# Tugunning nechta bolasi borligini
Tugunning ildizga masofasi
Tugunning umumiy soni
Tugunning bo‚Äòyi

+++++
Daraxt ko‚Äòruvi (Traversal) nima?
# Daraxtdagi barcha tugunlarni tartib bilan ko‚Äòrish jarayoni
Faqat ildiz tugunni ko‚Äòrish
Faqat barglarni ko‚Äòrish
Elementlarni o‚Äòchirish

+++++
Daraxtning pre-order ko‚Äòruvi qanday ishlaydi?
# Ildiz, chap bola, o‚Äòng bola tartibida
Chap bola, ildiz, o‚Äòng bola
Barglardan boshlab yuqoriga
Faqat barglarni

+++++
Daraxtning in-order ko‚Äòruvi qanday ishlaydi?
# Chap bola, ildiz, o‚Äòng bola tartibida
Ildiz, o‚Äòng bola, chap bola
Faqat ildiz tugunni
Faqat barglarni

+++++
Daraxtning post-order ko‚Äòruvi qanday ishlaydi?
# Chap bola, o‚Äòng bola, ildiz tartibida
Ildiz, chap bola, o‚Äòng bola
Faqat ildiz
Faqat barglar

+++++
Graf va daraxt orasidagi asosiy farq nima?
# Daraxtda sikl (aylana) bo‚Äòlmaydi
Grafda faqat bitta ildiz bor
Daraxtda elementlar ketma-ket saqlanadi
Grafda faqat ikki tugun bor

+++++
Balanslangan daraxt nimani anglatadi?
# Daraxtning chap va o‚Äòng subdaraxtlari balansi saqlangan
Faqat ildiz tugun bor
Faqat barglar mavjud
Tugunlar bitta yo‚Äòlda joylashgan

+++++
AVL daraxt nima?
# Balanslangan ikkilik qidiruv daraxti
Faqat ketma-ket massiv
Grafning turli turi
Daraxtning barglari

+++++
Binarny qidiruv daraxt (BST) qanday ishlaydi?
# Chap bolalar ildizdan kichik, o‚Äòng bolalar katta qiymatga ega
Har doim to‚Äòliq binarny daraxt
Faqat chap bolalar katta
Barchasi teng

+++++
Daraxtda chuqurlikni qanday hisoblash mumkin?
# Ildizdan eng uzoq barggacha bo‚Äòlgan yo‚Äòl uzunligi
Faqat ildiz tugunni hisoblash
Faqat barglarni hisoblash
Har bir tugunni sanash

+++++
Daraxtni chiziqli tarzda qanday ko‚Äòrish mumkin?
# Traversal yordamida
Faqat grafik ko‚Äòrinishda
Matritsada
Tasodifiy

+++++
Daraxtda sikl (aylana) paydo bo‚Äòlsa, u nima bo‚Äòladi?
# Daraxt bo‚Äòlmaydi, grafikga aylanadi
Yangi daraxt hosil bo‚Äòladi
Elementlar ko‚Äòpayadi
Hech narsa o‚Äòzgaradi

+++++
Daraxtlarda qaysi operatsiya tezkor qidiruvni ta‚Äôminlaydi?
# Binarny qidiruv daraxtlari
Oddiy bog‚Äòlangan ro‚Äòyhatlar
Massiv
Graf

+++++
Daraxtda har bir tugunning darajasi nimani anglatadi?
# Tugunning bolalari soni
Tugunning ota-ona soni
Tugunning bo‚Äòyi
Tugunning massivi
+++++
Binar qidiruv daraxtida (BST) chap bola qanday qiymatga ega bo‚Äòladi?
# Ildiz tugundan kichik qiymat
Ildiz tugundan katta qiymat
Ildiz bilan teng qiymat
Tasodifiy qiymat

+++++
Binar qidiruv daraxtida element qidiruv qanday amalga oshiriladi?
# Har bir tugunda kalit ildiz bilan solishtiriladi va chap yoki o‚Äòng subdaraxtga o‚Äòtiladi
Faqat ildizda qidiriladi
Faqat barglarda qidiriladi
Tasodifiy joylarda

+++++
Binar qidiruv daraxtida element qo‚Äòshish qanday amalga oshiriladi?
# Qidiruv orqali joy topilib, yangi tugun qo‚Äòshiladi
Har doim ildizga qo‚Äòshiladi
Faqat barglarga qo‚Äòshiladi
Element almashtiriladi

+++++
Binar qidiruv daraxtidan element o‚Äòchirishda uchta holat bor, ularni sanang:
# Barg tugun, bitta bola, ikki bola
Faqat bitta bola
Faqat barg tugun
Faqat ildiz tugun

+++++
Muvozanatlangan binar qidiruv daraxti nima?
# Daraxtning chap va o‚Äòng subdaraxtlari balansi saqlangan daraxt
Faqat ildiz mavjud daraxt
Faqat bitta bola bor
Hech qanday bola yo‚Äòq

+++++
AVL daraxti nimaga asoslangan?
# Har bir tugunning chap va o‚Äòng subdaraxt balansi -1, 0 yoki +1 bo‚Äòlishi kerak
Faqat barglar balansi
Faqat ildiz balansi
Tasodifiy qiymatlar

+++++
AVL daraxtida muvozanatni saqlash uchun qanday operatsiyalar qo‚Äòllaniladi?
# Burilishlar (rotatsiyalar)
Elementlarni o‚Äòchirish
Faol ko‚Äòchiruvlar
Elementlarni almashtirish

+++++
Binar qidiruv daraxtida elementni qidirishning eng yaxshi vaqt murakkabligi qanday?
# O(log n)
O(n)
O(n log n)
O(1)

+++++
Binar qidiruv daraxtining eng yomon holatdagi murakkabligi qanday?
# O(n)
O(log n)
O(n log n)
O(1)

+++++
AVL daraxtida o‚Äòng burilish (right rotation) nima uchun ishlatiladi?
# Chap subdaraxt juda chuqur bo‚Äòlganda muvozanatni tiklash uchun
O‚Äòng subdaraxtni ko‚Äòpaytirish uchun
Element qo‚Äòshish uchun
Element o‚Äòchirish uchun

+++++
AVL daraxtida chap burilish (left rotation) nima vazifani bajaradi?
# O‚Äòng subdaraxt juda chuqur bo‚Äòlganda muvozanatni tiklash
Chap subdaraxtni ko‚Äòpaytirish
Elementlarni almashtirish
Boshqa daraxtga ko‚Äòchirish

+++++
Binar qidiruv daraxtiga yangi elementni qo‚Äòshishdan keyin nimani tekshirish kerak?
# Daraxtning muvozanati
Faqat ildiz tugunni
Faqat barglarni
Hech narsani

+++++
Element o‚Äòchirishda agar o‚Äòchirilayotgan tugun ikki bolaga ega bo‚Äòlsa, nima qilinadi?
# O‚Äòchiriladigan tugun o‚Äòrniga o‚Äòng subdaraxtdagi eng kichik element olinadi
Element o‚Äòchirilib ketadi
Faqat chap subdaraxt ko‚Äòchiriladi
Hech narsa qilinmaydi

+++++
Binar qidiruv daraxtida elementni qidirishda qaysi holatda barcha tugunlar tekshiriladi?
# Daraxt chiziqli (muvozanatsiz) bo‚Äòlsa
Har doim
Hech qachon
Faqat ildizda

+++++
AVL daraxti qaysi holatda muvozanatni tiklash uchun ikki burilish amalga oshiriladi?
# Chap-o‚Äòng yoki o‚Äòng-chap holatlarida
Faqat chap chap
Faqat o‚Äòng o‚Äòng
Hech qachon

+++++
Binar qidiruv daraxtining qaysi xususiyati qidiruvni samarali qiladi?
# Chap subdaraxtdagi barcha elementlar ildizdan kichik, o‚Äòngdagilar katta
Tugunlarning tartibsizligi
Faqat ildizda element bo‚Äòlishi
Elementlar ketma-ketligi

+++++
Binar qidiruv daraxtida o‚Äòchirishdan keyin nimani bajarish kerak?
# Muvozanatni tekshirish va zarur bo‚Äòlsa burilishlar qilish
Faqat ildizni o‚Äòzgartirish
Element qo‚Äòshish
Hech narsa

+++++
Muvozanatlangan binar daraxtlar qaysi algoritmlar samaradorligini oshiradi?
# Qidiruv, qo‚Äòshish va o‚Äòchirish
Faqat qidiruv
Faqat qo‚Äòshish
Faqat o‚Äòchirish

+++++
Binar qidiruv daraxtining balansi buzilganda nimani bajarish kerak?
# Burilishlar yordamida muvozanatni tiklash
Elementlarni almashtirish
Elementlarni o‚Äòchirish
Hech narsani qilmaslik
+++++
Heap daraxti nima?
# Maxsus binar daraxt bo‚Äòlib, har bir ota-ona tugun bolalaridan katta (yoki kichik) qiymatga ega
Oddiy binar daraxt
Faqat to‚Äòliq binar daraxt
Ierarxik graflar yig‚Äòindisi

+++++
Max-heap nima?
# Har bir ota-ona bolalaridan katta yoki teng qiymatga ega bo‚Äòlgan heap
Har bir ota-ona bolalaridan kichik qiymatga ega
Faqat barglar katta
Faqat ildiz kichik

+++++
Min-heap nima?
# Har bir ota-ona bolalaridan kichik yoki teng qiymatga ega bo‚Äòlgan heap
Har bir ota-ona bolalaridan katta qiymatga ega
Faqat barglar kichik
Faqat ildiz katta

+++++
Heap daraxti qanday ko‚Äòrinishda tashkil etiladi?
# To‚Äòliq binar daraxt ko‚Äòrinishida
Tasodifiy daraxt
Faqat chap yonlama daraxt
Faqat o‚Äòng yonlama daraxt

+++++
Heapni massiv yordamida qanday ifodalash mumkin?
# Elementlar ketma-ket joylashgan massivda ota-ona va bolalar indekslari hisoblanadi
Har bir element alohida massivda
Faqat bitta massivda ildiz
Massivda faqat barglar

+++++
Heapda ota-onaning chap bolasi indeksini massivda qanday topamiz?
# 2*i + 1
i - 1
i / 2
2*i

+++++
Heapda ota-onaning o‚Äòng bolasi indeksini massivda qanday topamiz?
# 2*i + 2
i + 1
i * 3
2*i - 1

+++++
Heapda ota-ona tugun indeksini massivda qanday topamiz?
# (i - 1) // 2
i + 1
i * 2
2*i + 1

+++++
Heap tuzilmasida qo‚Äòshish (insert) amali qanday bajariladi?
# Yangi element oxiriga qo‚Äòyilib, yuqoriga burilishlar orqali joylashadi
Faqat oxiriga qo‚Äòyiladi
Faqat boshidan qo‚Äòyiladi
Element almashtiriladi

+++++
Heapda o‚Äòchirish (delete) amali qaysi tugunni o‚Äòchiradi odatda?
# Ildiz tugunni
Oxirgi tugunni
O‚Äòng bolani
Chap bolani

+++++
Heapda o‚Äòchirishdan keyin nimani bajarish kerak?
# Pastga burilish (heapify) qilib muvozanatni tiklash
Element qo‚Äòshish
Hech narsa
Massivni tozalash

+++++
Heapify algoritmi nima uchun ishlatiladi?
# Daraxtda heap xususiyatini tiklash uchun
Elementlarni o‚Äòchirish uchun
Faqat massivni yaratish uchun
Tugunlarni almashtirish uchun

+++++
Heapni tashkil etishning tezkor usuli qaysi?
# Bottom-up (pastdan yuqoriga) heapify
Top-down
Tasodifiy qo‚Äòshish
Faqat o‚Äòchirish

+++++
Heapda maksimal qiymat qaerda joylashgan bo‚Äòladi?
# Ildizda (max-heap uchun)
Barglarda
Oxirida
Chap bolada

+++++
Heapda minimal qiymat qaerda joylashgan bo‚Äòladi?
# Ildizda (min-heap uchun)
Barglarda
Oxirida
Chap bolada

+++++
Heapda yangi element qo‚Äòshishning vaqt murakkabligi qancha?
# O(log n)
O(n)
O(1)
O(n log n)

+++++
Heapda maksimal qiymatni olish qanday amalga oshiriladi?
# Ildizdagi elementni olish
Oxirgi elementni olish
Barglardan qidirish
Tasodifiy elementni olish

+++++
Heapda elementlarni saralash uchun qaysi algoritm ishlatiladi?
# Heapsort
Bubblesort
Quicksort
Mergesort

+++++
Heapda o‚Äòchirishdan keyin heap xususiyatini tiklash uchun qanday amal bajariladi?
# Heapify (pastga burilish)
Element qo‚Äòshish
O‚Äòng burilish
Chap burilish

+++++
Heapdagi elementlarni qanday ko‚Äòrish mumkin?
# Traversal yordamida yoki massiv ko‚Äòrinishida
Faqat barglar
Faqat ildiz
Faqat tasodifiy
+++++
Graf nima?
# Tugunlar va ularni bog‚Äòlovchi yoylardan iborat to‚Äòplam
Faqat tugunlar yig‚Äòindisi
Faqat yoylar yig‚Äòindisi
Ierarxik daraxt

+++++
Qo‚Äòshma matrisa nimani ifodalaydi?
# Graflardagi tugunlar orasidagi bog‚Äòlanishni ifodalovchi kvadrat matrisa
Faqat tugunlar ro‚Äòyxati
Faqat yoylar ro‚Äòyxati
Grafning og‚Äòirligini

+++++
Mun–æsabatlar matrisasi nima?
# Grafdagi tugunlar orasidagi bog‚Äòlanishlarni 0 va 1 orqali ifodalaydi
Faqat og‚Äòirliklar
Faqat tugunlar soni
Faqat yoylar uzunligi

+++++
Qo‚Äòshnilik ro‚Äòyxati nimani ifodalaydi?
# Har bir tugun uchun unga qo‚Äòshnilar ro‚Äòyxati
Faqat tugunlarning tartibini
Faqat yoylar uzunligini
Faqat og‚Äòirliklarni

+++++
Yoylar ro‚Äòyxati nima?
# Grafdagi barcha yoylar ro‚Äòyxati, ularning boshlanish va tugash tugunlari bilan
Faqat tugunlar ro‚Äòyxati
Faqat bog‚Äòlanish darajasi
Faqat bitta tugun ro‚Äòyxati

+++++
Qo‚Äòshma matrisaning o‚Äòlchami qanday bo‚Äòladi?
# n x n, bu yerda n ‚Äî tugunlar soni
n x m, m ‚Äî yoylar soni
2 x n
n x 1

+++++
Grafdagi qo‚Äòshnilik ro‚Äòyxati qanday ma‚Äôlumotni saqlaydi?
# Har bir tugun uchun unga bevosita bog‚Äòlangan tugunlar ro‚Äòyxatini
Faqat yoylarning sonini
Faqat tugunlarning raqamlarini
Faqat muhim tugunlarni

+++++
Munosabatlar matrisasida 0 va 1 nimani anglatadi?
# 1 ‚Äî bog‚Äòlanish bor, 0 ‚Äî bog‚Äòlanish yo‚Äòq
1 ‚Äî bog‚Äòlanish yo‚Äòq, 0 ‚Äî bor
Faqat raqamlar
Faqat indekslar

+++++
Qo‚Äòshma matrisada simmetriya nimani anglatadi?
# Yo‚Äònalmagan graf
Yo‚Äònalgan graf
Birinchi element kichik
Elementlar teng emas

+++++
Yoylar ro‚Äòyxati qaysi holat uchun qulayroq?
# Grafda yoylar soni kam bo‚Äòlsa
Grafda tugunlar soni kam bo‚Äòlsa
Faqat to‚Äòliq graflar uchun
Faqat ierarxik graflar uchun

+++++
Qo‚Äòshnilik ro‚Äòyxatida tugunlar qanday tartibda berilgan?
# Har bir tugun uchun unga bog‚Äòlangan tugunlarning ro‚Äòyxati
Faqat katta tartibda
Faqat kichik tartibda
Tasodifiy tartibda

+++++
Yo‚Äònalgan grafda munosabatlar matrisasi qanday bo‚Äòladi?
# Asimmetrik yoki simmetrik emas
Doim simmetrik
Doim asimmetrik
Faqat diagonal elementlari 1

+++++
Qo‚Äòshma matrisa qaysi holatda samaraliroq?
# Graf zich bo‚Äòlsa (ko‚Äòp yoylar mavjud bo‚Äòlsa)
Graf kam yoyli bo‚Äòlsa
Faqat yo‚Äònalgan graflar uchun
Faqat yo‚Äònalmagan graflar uchun

+++++
Qo‚Äòshnilik ro‚Äòyxati qaysi holatda samaraliroq?
# Graf kam yoyli bo‚Äòlsa (kam zich)
Graf zich bo‚Äòlsa
Faqat yo‚Äònalgan graflar uchun
Faqat yo‚Äònalmagan graflar uchun

+++++
Grafdagi tugunlar sonini qanday belgilaymiz?
# n bilan
m bilan
k bilan
x bilan

+++++
Yoylar sonini qanday belgilaymiz?
# m bilan
n bilan
k bilan
x bilan

+++++
Grafning yo‚Äònalgan yoki yo‚Äònalmaganligini qaysi tasvir yordamida aniqlash mumkin?
# Qo‚Äòshma matrisaning simmetriyasidan
Tugunlar ro‚Äòyxatidan
Yoylar ro‚Äòyxatidan emas
Faqat barglardan

+++++
Grafda DFS algoritmi nima vazifani bajaradi?
# Grafikda chuqurlik bo‚Äòyicha qidiruv
Bredth bo‚Äòyicha qidiruv
Element qo‚Äòshish
Element o‚Äòchirish

+++++
Grafda BFS algoritmi nima vazifani bajaradi?
# Grafikda kenglik bo‚Äòyicha qidiruv
Chuqurlik bo‚Äòyicha qidiruv
Element qo‚Äòshish
Element o‚Äòchirish

+++++
Qo‚Äòshma matrisaning elementlari nimani ko‚Äòrsatadi?
# I va j tugunlari orasidagi bog‚Äòlanishni
Faqat tugun nomi
Faqat og‚Äòirlik
Faqat yoylar uzunligi
+++++
BFS algoritmi nima vazifani bajaradi?
# Grafda eniga qarab qidiruv
Grafda tubiga qarab qidiruv
Faqat element qo‚Äòshish
Faqat element o‚Äòchirish

+++++
DFS algoritmi nima vazifani bajaradi?
# Grafda tubiga qarab qidiruv
Grafda eniga qarab qidiruv
Elementlarni saralash
Elementlarni o‚Äòchirish

+++++
BFS algoritmida qaysi ma‚Äôlumot tuzilmasidan ko‚Äòproq foydalaniladi?
# Navbat (queue)
Stek (stack)
Massiv
Bog‚Äòlangan ro‚Äòyxat

+++++
DFS algoritmida qaysi ma‚Äôlumot tuzilmasidan ko‚Äòproq foydalaniladi?
# Stek (stack) yoki rekursiya
Navbat (queue)
Massiv
Bog‚Äòlangan ro‚Äòyxat

+++++
BFS qaysi holatlarda samaraliroq ishlaydi?
# Eng qisqa yo‚Äòlni topishda
Grafning chuqurligini o‚Äòlchashda
Faqat daraxtlar uchun
Faqat yo‚Äònalgan graflar uchun

+++++
DFS algoritmi qaysi muammo uchun yaxshi yechim?
# Tsikllarni aniqlash va yo‚Äòl topishda
Eng qisqa yo‚Äòlni topishda
Faqat ierarxik daraxtlar uchun
Faqat bog‚Äòlangan graflar uchun

+++++
BFS algoritmida boshlang‚Äòich tugundan keyin qaysi tugunlar tashrif buyuriladi?
# Barcha qo‚Äòshni tugunlar birinchi navbatda
Faqat birinchi tugun
Faqat oxirgi tugun
Faqat ierarxik tugunlar

+++++
DFS algoritmida boshlang‚Äòich tugundan keyin qaysi tugunlar tashrif buyuriladi?
# Eng chuqur qismga borilgunga qadar ketma-ket
Barcha qo‚Äòshni tugunlar birinchi navbatda
Faqat oxirgi tugun
Faqat ildiz tugun

+++++
BFS va DFS algoritmlarining asosiy farqi nimada?
# BFS eniga, DFS tubiga qarab qidiradi
BFS faqat rekursiya, DFS faqat stek bilan ishlaydi
DFS faqat massiv bilan, BFS faqat ro‚Äòyxat bilan ishlaydi
Hech qanday farqi yo‚Äòq

+++++
BFS algoritmi uchun boshlang‚Äòich tugun qanday tanlanadi?
# Foydalanuvchi yoki muammo tomonidan beriladi
Har doim 0
Faqat oxirgi tugun
Tasodifiy

+++++
DFS algoritmi uchun boshlang‚Äòich tugun qanday tanlanadi?
# Foydalanuvchi yoki muammo tomonidan beriladi
Har doim 0
Faqat oxirgi tugun
Tasodifiy

+++++
BFS algoritmida tugunlar tashrifi qanday qayd etiladi?
# Maxsus belgilar (visited) yordamida
Hech qanday qayd etilmaydi
Faqat tugun nomi
Faqat o‚Äòchiriladi

+++++
DFS algoritmida tugunlar tashrifi qanday qayd etiladi?
# Maxsus belgilar (visited) yordamida
Hech qanday qayd etilmaydi
Faqat tugun nomi
Faqat o‚Äòchiriladi

+++++
DFS algoritmi uchun rekursiya qanday ishlaydi?
# Har bir tugun uchun uning qo‚Äòshnilariga chuqurroq kirish
Faqat tugun qo‚Äòshish
Faqat tugun o‚Äòchirish
Faqat massiv yaratish

+++++
BFS va DFS algoritmlarining murakkabligi qanday?
# O(V + E), bu yerda V ‚Äî tugunlar, E ‚Äî yoylar soni
O(V^2)
O(E^2)
O(1)

+++++
DFS algoritmi qaysi ma‚Äôlumot tuzilmasi yordamida amalga oshiriladi?
# Stek yoki rekursiv chaqiriqlar
Navbat
Massiv
Bog‚Äòlangan ro‚Äòyxat

+++++
BFS algoritmi qaysi sohalarda qo‚Äòllaniladi?
# Tarmoq qidiruvlari, eng qisqa yo‚Äòl topish
Faqat matematikada
Faqat rasm ishlashda
Faqat fayl tizimida

+++++
DFS algoritmi qaysi sohalarda qo‚Äòllaniladi?
# Tsikl aniqlash, komponentlarni ajratish
Faqat tarmoqda
Faqat grafik chizishda
Faqat fayl tizimida

+++++
DFS algoritmida qayta tashrif buyurilmaslik uchun nima qilinadi?
# Tashrif buyurilgan tugunlar belgilanadi
Har doim qayta tashrif buyuriladi
Faqat tugun nomlari yoziladi
Hech narsa qilinmaydi
+++++
Graflarda eng qisqa yo‚Äòlni aniqlash vazifasi nima?
# Tugunlar orasidagi eng qisqa yo‚Äòlni topish
Faqat tugunlarni sanash
Faqat yoylarni o‚Äòchirish
Faqat grafni chizish

+++++
Deykstra algoritmi qanday graflar uchun mo‚Äòljallangan?
# Og‚Äòirliklari manfiy bo‚Äòlmagan yo‚Äònalgan graflar
Faqat manfiy og‚Äòirlikli graflar
Faqat yo‚Äònalmagan graflar
Faqat ierarxik daraxtlar

+++++
Ford-Bellman algoritmi qaysi holatlarda ishlaydi?
# Manfiy og‚Äòirliklarga ega bo‚Äòlgan graflarda ham
Faqat manfiy og‚Äòirliksiz graflarda
Faqat yog‚Äòoch daraxtlarda
Faqat ierarxik graflarda

+++++
Floyd-Warshall algoritmi nima vazifani bajaradi?
# Barcha tugunlar orasidagi eng qisqa yo‚Äòllarni topish
Faqat boshlang‚Äòichdan bitta tugungacha yo‚Äòlni topish
Faqat oxirgi tugunga yo‚Äòl topish
Faqat qisqa yoylarni sanash

+++++
Deykstra algoritmi qanday usul asosida ishlaydi?
# Eng qisqa masofani asta-sekin yangilab boradi
Tasodifiy qidiruv
Faqat rekursiya
Faqat stek yordamida

+++++
Ford-Bellman algoritmi qanday usulga asoslangan?
# Har bir yoyni takroran yangilab borish (relaksatsiya)
Tasodifiy qidiruv
Faqat massiv bilan ishlash
Faqat stek bilan ishlash

+++++
Floyd-Warshall algoritmi murakkabligi qanday?
# O(n^3), n ‚Äî tugunlar soni
O(n)
O(log n)
O(n!)

+++++
Deykstra algoritmining murakkabligi qanday?
# O((V + E) log V), V ‚Äî tugunlar, E ‚Äî yoylar soni
O(V)
O(E^2)
O(1)

+++++
Ford-Bellman algoritmining murakkabligi qanday?
# O(V * E)
O(V + E)
O(log V)
O(V^2)

+++++
Floyd-Warshall algoritmi qaysi turdagi graflar uchun qo‚Äòllaniladi?
# Yo‚Äònalgan va yo‚Äònalmagan graflar uchun
Faqat yo‚Äònalgan graflar uchun
Faqat yo‚Äònalmagan graflar uchun
Faqat ierarxik daraxtlar uchun

+++++
Deykstra algoritmi qaysi ma‚Äôlumot tuzilmasidan foydalanadi?
# Minimal ustuvor navbat (priority queue)
Oddiy navbat (queue)
Stek (stack)
Massiv

+++++
Ford-Bellman algoritmi qanday holatlarda xatolik yuzaga keladi?
# Manfiy sikllar mavjud bo‚Äòlsa
Faqat katta graflarda
Faqat kichik graflarda
Faqat yo‚Äònalgan graflarda

+++++
Floyd-Warshall algoritmi qanday printsip asosida ishlaydi?
# Dynamic programming
Greedy
Divide and conquer
Tasodifiy qidiruv

+++++
Deykstra algoritmi qanday vaziyatda noto‚Äòg‚Äòri natija beradi?
# Grafda manfiy og‚Äòirliklar bo‚Äòlsa
Faqat kichik graflarda
Faqat katta graflarda
Faqat yo‚Äònalgan graflarda

+++++
Ford-Bellman algoritmi qanday natija beradi?
# Har bir tugunga eng qisqa masofani
Faqat boshlang‚Äòich tugunga
Faqat oxirgi tugunga
Faqat yoylarga

+++++
Floyd-Warshall algoritmi qanday natija beradi?
# Barcha tugunlar orasidagi eng qisqa yo‚Äòllar matrisi
Faqat boshlang‚Äòich tugunlar
Faqat oxirgi tugunlar
Faqat bog‚Äòlanishlar soni

+++++
Deykstra algoritmi qaysi holatda samaraliroq?
# Graf zich bo‚Äòlmasa va manfiy og‚Äòirliklarsiz bo‚Äòlsa
Faqat manfiy og‚Äòirliklarda
Faqat ierarxik daraxtlarda
Faqat katta sikllarda

+++++
Ford-Bellman algoritmida nechta iteratsiya bajariladi?
# Tugunlar sonidan bitta kam
Hech qachon iteratsiya qilinmaydi
Cheksiz
Faqat bittagina

+++++
Floyd-Warshall algoritmida asosiy sikl nechta marta ishlaydi?
# Uch marta: har bir tugun uchun uch marta aylantiriladi
Bir marta
Ikki marta
To‚Äòrt marta

+++++
Eng qisqa yo‚Äòlni aniqlashda Deykstra algoritmida boshlang‚Äòich tugun qanday tanlanadi?
# Foydalanuvchi tomonidan belgilanadi
Har doim 0
Tasodifiy
Faqat oxirgi tugun

+++++
Ford-Bellman algoritmi qanday holatda samaraliroq?
# Manfiy og‚Äòirlikli yoylar bo‚Äòlsa
Faqat musbat og‚Äòirliklarda
Faqat siklsiz graflarda
Faqat kichik graflarda

+++++
Floyd-Warshall algoritmida manfiy sikllarni aniqlash mumkinmi?
# Ha, diagonal elementlar manfiy bo‚Äòlsa sikl bor
Yo‚Äòq
Faqat Deykstra algoritmida mumkin
Faqat Ford-Bellman algoritmida mumkin

+++++
Deykstra algoritmi qaysi ma‚Äôlumotlar tuzilmasi yordamida tezlashtiriladi?
# Minimal ustuvor navbat (priority queue)
Oddiy massiv
Stek
Oddiy navbat

+++++
Eng qisqa yo‚Äòlni aniqlash algoritmlaridan qaysi biri barcha tugunlar orasidagi masofani aniqlaydi?
# Floyd-Warshall
Deykstra
Ford-Bellman
BFS

`;

        let allQuestions = [];
        let currentQuestions = [];
        let currentQuestionIndex = 0;
        let score = 0;
        let timer;
        let timeLeft = 30;
        let answered = false;
        let testCount = 0;

        // Savollarni parse qilish - TO'G'RI JAVOBNI ANIQLASH
        function parseQuestions(content) {
            const blocks = content.split('+++++').filter(block => block.trim() !== '');
            blocks.forEach(block => {
                const lines = block.trim().split('\n');
                if (lines.length > 1) {
                    const questionText = lines[0];
                    const answers = [];
                    let correctAnswerText = null;
                    
                    // Avval to'g'ri javobni topamiz
                    for (let i = 1; i < lines.length; i++) {
                        if (lines[i].startsWith('#')) {
                            correctAnswerText = lines[i].substring(1).trim();
                            break;
                        }
                    }
                    
                    // Barcha javoblarni yig'amiz
                    for (let i = 1; i < lines.length; i++) {
                        if (lines[i].trim() === '') continue;
                        
                        const answerText = lines[i].startsWith('#') 
                            ? lines[i].substring(1).trim() 
                            : lines[i].trim();
                            
                        answers.push({
                            text: answerText,
                            correct: answerText === correctAnswerText
                        });
                    }
                    
                    if (answers.length > 0 && correctAnswerText) {
                        allQuestions.push({ 
                            question: questionText, 
                            answers: shuffleArray(answers),
                            correctAnswerText: correctAnswerText
                        });
                    }
                }
            });
        }

        // Massivni aralashtirish
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Dasturni boshlash
        function initTest() {
            parseQuestions(fileContent);
            currentQuestions = shuffleArray([...allQuestions]).slice(0, 50);
            startTest();
        }

        // Testni boshlash
        function startTest() {
            document.querySelector('.start-page').style.display = 'none';
            document.getElementById('testContainer').style.display = 'block';
            currentQuestionIndex = 0;
            score = 0;
            testCount = 0;
            showQuestion();
        }

        // Savolni ko'rsatish
        function showQuestion() {
            if (currentQuestionIndex >= currentQuestions.length) {
                endTest();
                return;
            }
            
            answered = false;
            timeLeft = 30;
            updateTimerDisplay();
            
            const question = currentQuestions[currentQuestionIndex];
            document.getElementById('questionText').innerHTML = question.question;
            document.getElementById('progress').textContent = `Savol: ${currentQuestionIndex + 1}/${currentQuestions.length}`;
            
            const optionsContainer = document.getElementById('optionsContainer');
            optionsContainer.innerHTML = '';
            
            question.answers.forEach((answer, index) => {
                const label = document.createElement('label');
                label.innerHTML = `
                    <input type="radio" name="question" value="${index}">
                    ${answer.text}
                `;
                optionsContainer.appendChild(label);
            });
            
            // Radio tugmalariga event listener qo'shamiz
            document.querySelectorAll('#optionsContainer input[type="radio"]').forEach((radio, index) => {
                radio.addEventListener('change', () => {
                    checkAnswer(index, question.correctAnswerText, question.answers);
                });
            });
            
            startTimer();
        }

        // Taymerni boshlash
        function startTimer() {
            clearInterval(timer);
            timer = setInterval(() => {
                timeLeft--;
                updateTimerDisplay();
                
                if (timeLeft <= 0 && !answered) {
                    clearInterval(timer);
                    const question = currentQuestions[currentQuestionIndex];
                    showCorrectAnswer(question.correctAnswerText, question.answers);
                    moveToNextQuestion();
                }
            }, 1000);
        }

        // Taymerni yangilash
        function updateTimerDisplay() {
            document.getElementById('time').textContent = timeLeft;
            const percentage = (timeLeft / 30) * 100;
            document.getElementById('timerBar').style.width = `${percentage}%`;
            
            const timerBar = document.getElementById('timerBar');
            if (timeLeft <= 10) {
                timerBar.style.backgroundColor = '#f44336';
            } else if (timeLeft <= 20) {
                timerBar.style.backgroundColor = '#FF9800';
            } else {
                timerBar.style.backgroundColor = '#4CAF50';
            }
        }

        // Javobni tekshirish
        function checkAnswer(selectedIndex, correctAnswerText, answers) {
            if (answered) return;
            answered = true;
            clearInterval(timer);
            
            const selectedAnswer = answers[selectedIndex];
            const isCorrect = selectedAnswer.text === correctAnswerText;
            
            if (isCorrect) {
                score++;
            }
            
            // Barcha javoblarni ko'rsatish
            const options = document.querySelectorAll('#optionsContainer label');
            options.forEach((label, index) => {
                const answer = answers[index];
                if (answer.text === correctAnswerText) {
                    label.classList.add('correct');
                } else if (index === selectedIndex && !isCorrect) {
                    label.classList.add('incorrect');
                }
            });
            
            moveToNextQuestion();
        }

        // To'g'ri javobni ko'rsatish (vaqt tugaganda)
        function showCorrectAnswer(correctAnswerText, answers) {
            const options = document.querySelectorAll('#optionsContainer label');
            options.forEach((label, index) => {
                if (answers[index].text === correctAnswerText) {
                    label.classList.add('correct');
                }
            });
        }

        // Keyingi savolga o'tish
        function moveToNextQuestion() {
            setTimeout(() => {
                currentQuestionIndex++;
                testCount++;
                
                if (testCount % 50 === 0 && testCount > 0) {
                    showIntermediateResult();
                } else {
                    showQuestion();
                }
            }, 3000);
        }

        // Oraliq natija
        function showIntermediateResult() {
            document.getElementById('questionText').textContent = '';
            document.getElementById('optionsContainer').innerHTML = '';
            document.getElementById('result').innerHTML = `
                <h2>Oraliq Natija</h2>
                <p>Siz ${score} ta savoldan to'g'ri javob berdingiz!</p>
                <p>Foizda: ${Math.round((score / 50) * 100)}%</p>
            `;
            
            setTimeout(() => {
                document.getElementById('result').innerHTML = '';
                showQuestion();
            }, 5000);
        }

        // Testni tugatish
        function endTest() {
            document.getElementById('questionText').textContent = '';
            document.getElementById('optionsContainer').innerHTML = '';
            document.getElementById('result').innerHTML = `
                <h2>Test Yakunlandi!</h2>
                <p>Umumiy natija: ${score} ta savoldan to'g'ri javob berdingiz!</p>
                <p>Foizda: ${Math.round((score / currentQuestions.length) * 100)}%</p>
                <button class="btn btn-restart" onclick="restartTest()">Qaytadan Boshlash</button>
                <button class="btn" onclick="location.reload()">Bosh Sahifa</button>
            `;
        }

        // Testni qayta boshlash
        function restartTest() {
            currentQuestions = shuffleArray([...allQuestions]).slice(0, 50);
            document.getElementById('result').innerHTML = '';
            startTest();
        }

        // Boshlash tugmasi
        document.getElementById('startBtn').addEventListener('click', initTest);
    </script>
</body>
</html>
