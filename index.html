<!DOCTYPE html>
<html lang="uz">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My test</title>
    <link rel="icon" href="https://cdn-icons-png.flaticon.com/512/2936/2936886.png" type="image/x-icon">
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 0;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            flex-direction: column;
            transition: background-color 0.5s ease, color 0.5s ease;
            position: relative;
            background-color: #f5f5f5;
        }

        .dark-mode {
            background-color: #121212;
            color: #e0e0e0;
        }

        .dark-mode .container {
            background-color: #1e1e1e;
            color: #e0e0e0;
        }

        .dark-mode .question {
            color: #e0e0e0;
        }

        .dark-mode .options label {
            background-color: #2d2d2d;
            color: #e0e0e0;
        }

        .dark-mode .options label:hover {
            background-color: #3d3d3d;
        }

        .container {
            width: 95%;
            max-width: 800px;
            background: #fff;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            text-align: center;
            margin: 20px 0;
            transition: all 0.3s ease;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 20px;
            color: #333;
            transition: color 0.3s ease;
        }

        #startBtn {
            background-color: #4CAF50;
            color: white;
            padding: 15px 30px;
            font-size: 18px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        #startBtn:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        #darkModeBtn {
            position: fixed;
            right: 20px;
            top: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            border: none;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #darkModeBtn:hover {
            transform: scale(1.1);
        }

        .question {
            font-size: 20px;
            margin-bottom: 25px;
            color: #333;
            font-weight: 500;
            line-height: 1.4;
            transition: color 0.3s ease;
        }

        .options {
            margin-bottom: 25px;
            text-align: left;
        }

        .options label {
            display: block;
            margin: 10px 0;
            padding: 12px 15px;
            font-size: 16px;
            border-radius: 8px;
            cursor: pointer;
            background-color: #f0f0f0;
            transition: all 0.3s ease;
            border: 1px solid #ddd;
        }

        .options label:hover {
            background-color: #e0e0e0;
        }

        .options input[type="radio"] {
            margin-right: 10px;
        }

        .correct {
            background-color: #4CAF50 !important;
            color: white !important;
            border-color: #4CAF50 !important;
        }

        .incorrect {
            background-color: #f44336 !important;
            color: white !important;
            border-color: #f44336 !important;
        }

        .btn {
            display: inline-block;
            padding: 12px 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            margin: 10px 5px;
            text-decoration: none;
        }

        .btn:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        .btn-restart {
            background-color: #FF9800;
        }

        .btn-restart:hover {
            background-color: #F57C00;
        }

        .timer-container {
            width: 100%;
            height: 8px;
            background-color: #e0e0e0;
            border-radius: 4px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .timer-bar {
            height: 100%;
            width: 100%;
            background-color: #4CAF50;
            transition: width 1s linear;
            border-radius: 4px;
        }

        .timer-text {
            font-size: 16px;
            margin-bottom: 10px;
            color: #666;
        }

        #result {
            font-size: 24px;
            text-align: center;
            margin: 20px 0;
            color: #333;
            font-weight: bold;
            transition: color 0.3s ease;
        }

        .progress {
            font-size: 18px;
            margin-bottom: 15px;
            color: #666;
        }

        .start-page {
            text-align: center;
            padding: 20px;
            max-width: 600px;
            width: 90%;
        }

        .start-page h1 {
            font-size: 32px;
            margin-bottom: 30px;
            color: #333;
        }

        .start-page p {
            font-size: 18px;
            color: #666;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        @media (max-width: 600px) {
            .container {
                padding: 15px;
                width: 95%;
            }
            
            .question {
                font-size: 18px;
            }
            
            .options label {
                padding: 10px 12px;
                font-size: 15px;
            }
            
            #darkModeBtn {
                width: 40px;
                height: 40px;
                font-size: 16px;
                right: 15px;
                top: 15px;
            }
            
            .start-page h1 {
                font-size: 26px;
            }
            
            .start-page p {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="start-page">
        <h1>My test</h1>
        <p>Testda har bir savolga 30 soniya vaqt beriladi. To'g'ri javob yashil, noto'g'ri javob qizil rangda ko'rsatiladi. Har 50 ta savoldan keyin natijangiz ko'rsatiladi.</p>
        <button id="startBtn" class="btn">Testni Boshlash</button>
    </div>

    <div class="container" id="testContainer" style="display: none;">
        <div class="timer-text">Qolgan vaqt: <span id="time">30</span> soniya</div>
        <div class="timer-container">
            <div class="timer-bar" id="timerBar"></div>
        </div>
        <div class="progress" id="progress">Savol: 1/50</div>
        <div class="question" id="questionText"></div>
        <div class="options" id="optionsContainer"></div>
        <div id="result"></div>
    </div>

    <button id="darkModeBtn" onclick="toggleDarkMode()">ğŸŒ™</button>

    <script>
        // Dark mode
        let darkMode = localStorage.getItem('darkMode') === 'true';
        
        function toggleDarkMode() {
            darkMode = !darkMode;
            localStorage.setItem('darkMode', darkMode);
            updateDarkMode();
        }
        
        function updateDarkMode() {
            document.body.classList.toggle('dark-mode', darkMode);
            document.getElementById('darkModeBtn').textContent = darkMode ? 'â˜€ï¸' : 'ğŸŒ™';
        }
        
        // Boshlang'ich dark mode holati
        updateDarkMode();
        
        // Test ma'lumotlari
        const fileContent = `Maâ€™lumotlar tuzilmasi nima?
# Maâ€™lumotlarni samarali saqlash va foydalanish usuli
Grafik interfeys asosida ishlaydi
Faqat tashqi qurilmalar uchun
Axborotni uzatish uchun aloqa protokoli

+++++
Abstrakt maâ€™lumotlar tuzilmasi nimani anglatadi?
# Foydalanuvchi koâ€˜radigan, lekin ichki amalga oshirilishi yashirilgan model
Faqat koâ€˜rinadigan fayl tizimi
Fizik xotiraning toâ€˜liq tavsifi
Axborotni chiqaruvchi qurilma

+++++
Massiv qanday tuzilma hisoblanadi?
# Ketma-ket joylashgan bir xil turdagi elementlar toâ€˜plami
Faqat grafik tuzilma
Tasodifiy elementlar ketma-ketligi
Axborotni bosma holda saqlovchi tuzilma

+++++
Stek qanday ishlaydi?
# Oxirgi kirgan birinchi chiqadi (LIFO)
Birinchi kirgan birinchi chiqadi (FIFO)
Elementlar faqat oâ€˜rtasidan chiqariladi
Faqat tasodifiy kirish orqali ishlaydi

+++++
Queue (navbat) qanday asosiy prinsipga ega?
# Birinchi kirgan birinchi chiqadi (FIFO)
Oxirgi kirgan birinchi chiqadi (LIFO)
Faqat indeks orqali chaqiriladi
Faqat juft sonlar uchun ishlaydi

+++++
Algoritm tahlilining asosiy maqsadi nima?
# Algoritmning samaradorligini baholash
Kod yozilish stilini aniqlash
Rasmiy dizaynni tasdiqlash
Foydalanuvchi interfeysini chizish

+++++
Asimptotik tahlilda O(n) nimani bildiradi?
# Vazifani bajarish vaqti kirish hajmiga proporsional
Vaqt oâ€˜zgarmas boâ€˜ladi
Foydalanilmaydigan algoritm
Faqat grafik chizmalar bilan bogâ€˜liq

+++++
Abstrakt tiplar misoliga qaysi biri kiradi?
# Stack (stek)
Tasma printer
Sensorli ekran
Uzatish kabeli

+++++
Maâ€™lumotlar tuzilmalarining ikkiga boâ€˜linishi nimani bildiradi?
# Statik va dinamik tuzilmalar
Sonli va matnli fayllar
Axborot va uskunalar
Kompyuter va telefon uchun

+++++
Rekursiv algoritm nima?
# Oâ€˜zini oâ€˜zi chaqiruvchi algoritm
Faqat bitta amalni bajargan algoritm
Kodda sikl mavjud boâ€˜lmagan algoritm
Tashqi qurilmasiz ishlaydigan algoritm

+++++
Maâ€™lumotlarning boshlangâ€˜ich turi qanday boâ€˜ladi?
# Oddiy (primitive) turlar
Chuqur oâ€˜zaro bogâ€˜langan modullar
Murakkab grafik komponentlar
Tarmoqli qurilma signallari

+++++
Maâ€™lumotlarni ifodalash bosqichlaridan biri nima?
# Kodlash
Siklga qoâ€˜yish
Sensorli chiqarish
Blok sxema chizish

+++++
Tartiblash algoritmlarining asosiy vazifasi nima?
# Elementlarni maâ€™lum tartibda joylashtirish
Xatoliklarni yashirish
Grafik interfeys yasash
Fayl tizimlarini oâ€˜chirish

+++++
Murakkablik darajasi O(1) boâ€˜lgan operatsiya qanday?
# Doimiy vaqt talab qiladi
Foydalanuvchi kiritmasiga bogâ€˜liq
Fayl hajmiga qarab oâ€˜zgaradi
Faqat dinamik massivda ishlaydi

+++++
Maâ€™lumotlar tuzilmasining asosiy xususiyatlaridan biri nima?
# Maâ€™lumotlarga kirish tezligi
Grafik interfeys dizayni
Dastur tilining versiyasi
Tashqi xotira oâ€˜lchami
+++++
Rekursiv funksiyaning asosiy xususiyati nima?
# Oâ€˜zini oâ€˜zi chaqiradi
Faqat tashqi funksiyalarni chaqiradi
Sikl bilan ishlaydi
Faqat massivlar bilan ishlaydi

+++++
Rekursiya qanday hollarda toâ€˜xtaydi?
# Bazaviy holatga yetganda
Fayl ochilganda
Massiv tugaganda
Xatolik chiqqanda

+++++
Fibonachchi sonlarini hisoblashda rekursiya qanday ishlatiladi?
# Har bir son avvalgi ikki son yigâ€˜indisi sifatida chaqiriladi
Faqat toq sonlar olinadi
Har safar 1 ga kamaytiriladi
Natija faqat 0 boâ€˜ladi

+++++
Rekursiv algoritmda â€œbazaviy holatâ€ nima?
# Rekursiyani toâ€˜xtatish sharti
Natijani ekranga chiqarish holati
Dastur ishlamay qolishi
Sonlarni teskari aylantirish

+++++
Rekursiv funksiyaning kamchiligi nima boâ€˜lishi mumkin?
# Stack overflow xatoligiga olib kelishi mumkin
Doim eng samarali boâ€˜ladi
Faqat Pythonda ishlaydi
Xotira talab qilmaydi

+++++
Faktorialni rekursiv hisoblashda qanday ifoda ishlatiladi?
# n * factorial(n - 1)
n + factorial(n)
n / factorial(n + 1)
n - 1 * factorial(n)

+++++
Rekursiv funksiyalar qanday tuzilmada saqlanadi?
# Stack (stek)
Queue (navbat)
Graf
Hash jadval

+++++
Rekursiyani iteratsiyaga nisbatan farqlovchi jihat nima?
# Oâ€˜zini chaqirish orqali ishlashi
Faoliyatini foydalanuvchi belgilar
Faqat grafik muhitda ishlashi
Toâ€˜liq kompilyatsiya talab etishi

+++++
Rekursiv algoritm samaradorligi nimaga bogâ€˜liq?
# Bazaviy holatga tez yetishga
Chuqurlikdagi massivlar soniga
Monitor ekraniga
Funksiya nomining uzunligiga

+++++
Tail-recursion nima?
# Oxirgi chaqiruv rekursiv boâ€˜lgan funksiya
Faqat bitta parametrli funksiya
Massivni teskari oâ€˜qish
Funksiya chaqirilmasligi
+++++
Qidiruv algoritmining asosiy maqsadi nima?
# Kerakli elementni topish
Grafni chizish
Fayl hajmini kamaytirish
Xotirani formatlash

+++++
Chiziqli qidiruv qanday ishlaydi?
# Elementlarni boshidan oxirigacha tekshiradi
Massivni ikkiga boâ€˜ladi
Faqat juft indeksli elementlarni qidiradi
Faqat oxirgi elementni tekshiradi

+++++
Binar qidiruv uchun qanday shart kerak?
# Massiv oldindan saralangan boâ€˜lishi kerak
Elementlar unikal boâ€˜lishi kerak
Faqat matnli maâ€™lumotlar boâ€˜lishi kerak
Massiv teskari tartibda boâ€˜lishi kerak

+++++
Binar qidiruv qanday ishlaydi?
# Har safar massivni ikkiga boâ€˜lib, kerakli qismini tekshiradi
Barcha elementlarni ketma-ket tekshiradi
Faqat oxirgi uchta elementni solishtiradi
Massivni aralashtirib yuboradi

+++++
Chiziqli qidiruvning yomon holatdagi murakkabligi qanday?
# O(n)
O(1)
O(log n)
O(n log n)

+++++
Binar qidiruvning eng yaxshi holatdagi murakkabligi qanday?
# O(1)
O(n)
O(n^2)
O(n!)

+++++
Binar qidiruvda element topilmasa nima boâ€˜ladi?
# Qidiruv davom etadi va oxirida topilmadi deb qaytaradi
Topilmagan element avtomatik qoâ€˜shiladi
Qidiruv boshlanishiga qaytadi
Barcha elementlar oâ€˜chiriladi

+++++
Chiziqli qidiruvda birinchi topilgan element bilan nima qilinadi?
# Qidiruv toâ€˜xtaydi
Keyingi elementga oâ€˜tiladi
Massiv teskari aylanadi
Yangi element qoâ€˜shiladi

+++++
Binar qidiruv algoritmi uchun massiv qanday boâ€˜lishi kerak?
# Saralangan
Notoâ€˜gâ€˜ri tartiblangan
Faqat bitta elementdan iborat
Null qiymatlardan iborat

+++++
Qidiruv algoritmlari qaysi sohalarda qoâ€˜llaniladi?
# Maâ€™lumotlar bazasi, qidiruv tizimlari
Faqat grafik chizishda
Foydalanuvchi interfeysda
Qurilma drayverlarida

+++++
Qidiruv algoritmlarining samaradorligi nimaga bogâ€˜liq?
# Elementlar soni va maâ€™lumotlar tartibiga
Foydalanuvchi kompyuteri ekraniga
Sensorlar holatiga
Tashqi qurilma brendiga

+++++
Binar qidiruv natijasi topilsa nima qaytaradi?
# Elementning indeksi
Elementning matni
Null qiymat
Butun massiv

+++++
Chiziqli qidiruvda element mavjud boâ€˜lmasa nima boâ€˜ladi?
# Butun massiv tekshiriladi va -1 qaytariladi
Xatolik chiqariladi
Biror qiymat avtomatik tanlanadi
Massiv saralanadi

+++++
Qidiruv algoritmlarini optimallashtirishning usuli qanday?
# Maâ€™lumotlarni oldindan saralash
Har bir elementni ikki marta tekshirish
Tasodifiy indeks tanlash
Xotirani tozalash

+++++
Interpolatsion qidiruv qachon samaraliroq?
# Maâ€™lumotlar bir tekisda taqsimlangan boâ€˜lsa
Maâ€™lumotlar kichik boâ€˜lsa
Faqat matn boâ€˜lsa
Grafik boâ€˜lsa
+++++
Xeshlash algoritmining asosiy vazifasi nima?
# Maâ€™lumotni unikal kalitga aylantirish
Maâ€™lumotni grafik koâ€˜rinishga oâ€˜tkazish
Maâ€™lumotni avtomatik oâ€˜chirish
Maâ€™lumotni ekranda aks ettirish

+++++
Xesh jadval nima?
# Kalit-qiymat juftliklarini saqlovchi maâ€™lumotlar tuzilmasi
Faqat massivdan iborat tuzilma
Ikki oâ€˜lchamli grafik fayl
Matnli fayl tuzilmasi

+++++
Xesh funksiyasi qanday ishlaydi?
# Kiruvchi qiymatni maâ€™lum indeksga moslab beradi
Maâ€™lumotni ketma-ket qidiradi
Elementlarni teskari oâ€˜giradi
Massivni saralaydi

+++++
Xesh toâ€˜qnashuvi (collision) deganda nima tushuniladi?
# Ikkita qiymat bir xil xesh indeksga ega boâ€˜lishi
Massiv elementlari teskari boâ€˜lishi
Faylning yoâ€˜qolib qolishi
Grafik interfeys notoâ€˜gâ€˜ri chizilishi

+++++
Xesh toâ€˜qnashuvlarini hal qilish usullaridan biri bu:
# Zanjirli bogâ€˜lash (chaining)
Rekursiv tozalash
Kompressiyalash
Matnni kodlash

+++++
Ochiq adresatsiyalash usuli nima?
# Boâ€˜sh joy topilguncha indeksni koâ€˜chirish
Massivni toâ€˜liq qayta qurish
Elementni oâ€˜chirish
Grafni bogâ€˜lash

+++++
Xesh funksiyalar qaysi algoritmlarda keng qoâ€˜llaniladi?
# Parollarni saqlashda
Grafik chizishda
Multimedia fayllarda
Sensorli ekranlarda

+++++
Xesh funksiyaning yaxshi boâ€˜lishi uchun nima kerak?
# Toâ€˜qnashuv ehtimolini kamaytirishi kerak
Faqat tasodifiy sonlar hosil qilishi
Faqat harflar bilan ishlashi
Doim 0 natija qaytarishi

+++++
Xesh jadvaldagi indekslar qanday aniqlanadi?
# Xesh funksiyasi orqali
Tasodifiy tanlanadi
Raqamlarni qiyoslab
Graf boâ€˜yicha

+++++
Maâ€™lumotlar bazasida xesh funksiyalari nima uchun kerak?
# Tezroq qidirish va taqqoslash uchun
Fayl nomini oâ€˜zgartirish uchun
Rasm yuklash uchun
Maâ€™lumotlarni tahrirlash uchun

+++++
Xesh jadvalning asosiy ustunligi nima?
# Qidiruv va qoâ€˜shish tezligi yuqori boâ€˜ladi
Xotirani tozalab turadi
Grafik interfeysni boshqaradi
Tasodifiy indeks yaratadi

+++++
Xesh funksiyasi qanday kirishni qamrab oladi?
# Belgilar, raqamlar yoki matnlar
Faqat rasmlar
Faqat audio fayllar
Faqat video fayllar

+++++
Qaysi biri xesh toâ€˜qnashuvi yuz berishining sababi boâ€˜lishi mumkin?
# Bir nechta kalitlar bir xil indeksga tushishi
Qidiruv notoâ€˜gâ€˜ri boâ€˜lishi
Massiv uzun boâ€˜lishi
Fayl yoâ€˜q boâ€˜lishi

+++++
Xesh jadvalda maâ€™lumotlar qanday saqlanadi?
# Kalit-qiymat (key-value) juftliklarida
Faqat sonlar shaklida
Koâ€˜p oâ€˜lchamli massivda
Rasmlar koâ€˜rinishida

+++++
Eng mashhur xesh algoritmlaridan biri bu:
# SHA-256
HTML5
PNG
SQL
+++++
Saralash algoritmining asosiy vazifasi nima?
# Maâ€™lumotlarni tartibga keltirish
Maâ€™lumotlarni oâ€˜chirish
Xotirani tozalash
Grafik chizish

+++++
Bubble Sort algoritmi qanday ishlaydi?
# Yondosh elementlarni taqqoslab almashtiradi
Faqat indekslarni oâ€˜zgartiradi
Elementlarni tasodifiy joylashtiradi
Faoliyatni rekursiyaga asoslaydi

+++++
Insertion Sort algoritmining yondashuvi qanday?
# Har bir elementni mos joyiga qoâ€˜yadi
Elementlarni teskari tartibga oâ€˜tkazadi
Faqat juft sonlarni saralaydi
Maâ€™lumotlarni oâ€˜chiradi

+++++
Selection Sort algoritmida nima amalga oshiriladi?
# Har safar eng kichik (yoki katta) element tanlanadi
Elementlar ikki baravar ortadi
Faqat juft indeksli qiymatlar oâ€˜zgaradi
Xesh qiymatlar hosil qilinadi

+++++
Quick Sort qanday tamoyil asosida ishlaydi?
# Boâ€˜lish va hukmronlik (Divide and Conquer)
FIFO tartibi
Massivni ikki baravar uzunlashtirish
Stekka qoâ€˜shish orqali

+++++
Merge Sort algoritmining yondashuvi nima?
# Massivni ikkiga boâ€˜lib, soâ€˜ngra birlashtirish
Foydalanuvchi kiritgan qiymatlar asosida
Faqat matnli qiymatlarni saralash
Massivni toâ€˜gâ€˜ridan-toâ€˜gâ€˜ri teskari aylantirish

+++++
Bubble Sort algoritmining yomon holatdagi murakkabligi qanday?
# O(n^2)
O(1)
O(log n)
O(n log n)

+++++
Quick Sort algoritmining oâ€˜rtacha ishlash murakkabligi nima?
# O(n log n)
O(n^2)
O(2^n)
O(n!)

+++++
Saralash algoritmlarida "stabil" degani nimani anglatadi?
# Bir xil qiymatli elementlar joylashuvi saqlanib qoladi
Faqat toq sonlar saralanadi
Xotira sarfi doimiy boâ€˜ladi
Natija har doim teskari chiqadi

+++++
Qaysi algoritm rekursiv ishlaydi?
# Merge Sort
Selection Sort
Bubble Sort
Insertion Sort

+++++
Saralash algoritmini tanlashda eng muhim omil nima?
# Maâ€™lumot hajmi va tartibi
Foydalanuvchi ismi
Rasm formati
Dastur nomi

+++++
Hech qanday qoâ€˜shimcha xotira talab qilmaydigan saralash turi bu:
# In-place sort
Out-of-core sort
Grafik sort
Xesh sort

+++++
Saralash algoritmlari qaysi sohalarda qoâ€˜llaniladi?
# Maâ€™lumotlar bazasi, qidiruv tizimlari, grafikalar
Faqat brauzer sozlamalarida
Tarmoq simlarini ulanganda
Kompyuter ekranini tozalaganda

+++++
Heap Sort algoritmi qanday tuzilma asosida ishlaydi?
# Ikkilik heap daraxt
Massivlar tarmogâ€˜i
Xesh jadval
Graf koâ€˜rinishi

+++++
Quick Sort algoritmining eng yomon holatdagi murakkabligi qanday?
# O(n^2)
O(n log n)
O(1)
O(log n)
+++++
Statik massivning asosiy xususiyati nima?
# Oâ€˜lchami dastlab belgilangan va oâ€˜zgarmaydi
Oâ€˜lchami har doim oshadi
Elementlari faqat raqamlar boâ€˜ladi
Har doim teskari tartibda saqlanadi

+++++
Dinamik massivning asosiy afzalligi nima?
# Oâ€˜lchami dastur davomida oâ€˜zgarishi mumkin
Elementlar teskari saqlanadi
Faqat matnli qiymatlarni oladi
Xotirani faqat boshlangâ€˜ich qiymatlarda egallaydi

+++++
Chiziqli bogâ€˜langan roâ€˜yhat nima?
# Elementlar pointerlar orqali ketma-ket bogâ€˜langan tuzilma
Massivdagi elementlarning aralash joylashuvi
Tasodifiy fayl ochish usuli
Grafik koâ€˜rinishda jadval

+++++
Bir bogâ€˜lamli roâ€˜yhatda har bir tugun qanday bogâ€˜lanadi?
# Keyingi tugunga pointer orqali
Oldingi tugunga pointer orqali
Bosh tugunga bogâ€˜lanadi
Tasodifiy joyga

+++++
Ikki bogâ€˜lamli roâ€˜yhatda har bir tugun nechta pointerga ega?
# Ikki â€” oldingi va keyingi tugunlarga
Faqat bittaga
Uchta pointer
Pointerlar yoâ€˜q

+++++
Statik massivga yangi element qoâ€˜shish mumkinmi?
# Yoâ€˜q, oâ€˜lchami qatâ€™iy
Ha, doim mumkin
Faqat boshida qoâ€˜shish mumkin
Faqat oxirida qoâ€˜shish mumkin

+++++
Dinamik massivda elementni qanday qoâ€˜shish mumkin?
# Oâ€˜lchamni oâ€˜zgartirib yangi element joylash
Faqat oâ€˜chirib, qayta yaratish
Faqat oâ€˜lcham kamaytirish mumkin
Elementlar joyi oâ€˜zgarmaydi

+++++
Chiziqli bogâ€˜langan roâ€˜yhatda element qidirish qanday amalga oshadi?
# Tugunlarni ketma-ket tekshirish orqali
Indeks boâ€˜yicha toâ€˜gâ€˜ridan-toâ€˜gâ€˜ri kirish
Tasodifiy qidiruv
Massivdan foydalanish orqali

+++++
Bir bogâ€˜lamli roâ€˜yhatda elementni qanday qoâ€˜shish mumkin?
# Pointerni mos ravishda yangilash orqali
Massivga qoâ€˜shish bilan bir xil
Elementlarni teskari tartibda almashtirish bilan
Yangi roâ€˜yhat yaratish bilan

+++++
Ikki bogâ€˜lamli roâ€˜yhatda elementni oâ€˜chirishda nimaga eâ€™tibor beriladi?
# Oldingi va keyingi pointerlarni toâ€˜gâ€˜ri bogâ€˜lash
Faqat keyingi pointer yangilanadi
Faqat oldingi pointer yangilanadi
Pointerlar oâ€˜chirilmaydi

+++++
Statik va dinamik massiv orasidagi asosiy farq nima?
# Oâ€˜lcham oâ€˜zgartirilishi mumkin yoki yoâ€˜qligi
Maâ€™lumot turi
Massiv elementlari soni
Massiv nomi

+++++
Chiziqli bogâ€˜langan roâ€˜yhatni yaratishda qaysi operatsiya bajariladi?
# Tugunlar uchun xotira ajratish
Elementlarni saralash
Elementlarni nusxalash
Massivni tartiblash

+++++
Bir bogâ€˜lamli roâ€˜yhatda oxirgi tugunni topish uchun nima qilish kerak?
# Boshidan ketma-ket tugunlarni oâ€˜tkazish
Oxiridan boshlab qidirish
Tasodifiy element tanlash
Faqat indeks yordamida

+++++
Ikki bogâ€˜lamli roâ€˜yhat qaysi holatlarda afzal?
# Oldingi va keyingi elementlarga tez kira olish uchun
Faqat oddiy qidiruvda
Elementlarni massivda saqlash uchun
Elementlarni grafik koâ€˜rinishda

+++++
Dinamik massiv qanday maâ€™lumotlarni saqlashda qulay?
# Oâ€˜lchami oâ€˜zgaruvchi maâ€™lumotlar uchun
Faqat matnlar uchun
Faqat raqamlar uchun
Faqat bitta element uchun

+++++
Chiziqli bogâ€˜langan roâ€˜yhatda yangi elementni boshiga qoâ€˜shish uchun nimani oâ€˜zgartirish kerak?
# Bosh pointer va yangi tugun pointerini
Faqat oxirgi tugunni
Hech narsa oâ€˜zgarmaydi
Massiv oâ€˜lchamini

+++++
Bir bogâ€˜lamli roâ€˜yhatning kamchiligi nima?
# Orqaga qaytish qiyinligi
Tezkor qidiruv imkoniyati
Doim oâ€˜zgaruvchan oâ€˜lcham
Xotirani koâ€˜p ishlatish

+++++
Ikki bogâ€˜lamli roâ€˜yhatda yangi elementni qoâ€˜shish qiyinligi nimada?
# Oldingi va keyingi pointerlarni toâ€˜gâ€˜ri bogâ€˜lash
Faqat yangi tugunni yaratish
Massivni yangilash
Grafni chizish

+++++
Statik massiv qanday xotira taqsimotini talab qiladi?
# Ketma-ket bloklar
Tasodifiy bloklar
Pointerlar toâ€˜plami
Ikki oâ€˜lchamli massiv

+++++
Dinamik massivda boâ€˜sh joy yetarli boâ€˜lmasa nima qilinadi?
# Yangi katta joy ajratilib, elementlar koâ€˜chiriladi
Elementlar oâ€˜chiriladi
Elementlar teskari tartibda joylashtiriladi
Programma xatolik chiqaradi
+++++
Navbat (Queue) nima?
# Birinchi kirgan, birinchi chiqadi (FIFO) prinsipi asosida ishlaydi
Oxirgi kirgan, birinchi chiqadi (LIFO)
Tasodifiy tartibda ishlaydi
Elementlarni doim oâ€˜chiradi

+++++
Stek (Stack) qanday printsipda ishlaydi?
# Oxirgi kirgan, birinchi chiqadi (LIFO)
Birinchi kirgan, birinchi chiqadi (FIFO)
Tasodifiy kirish
Elementlarni teskari tartibda chiqaradi

+++++
Dek (Deque) maâ€™lumotlar tuzilmasining xususiyati nima?
# Elementlarni ikkala tomondan qoâ€˜shish va oâ€˜chirish mumkin
Faqat oxiridan qoâ€˜shish mumkin
Faqat boshidan oâ€˜chirish mumkin
Faqat bitta element saqlaydi

+++++
Navbatni massiv yordamida tasvirlashda indekslar qanday ishlaydi?
# Kirish oxirgi indeksda, chiqish bosh indeksda amalga oshadi
Kiruvchi va chiquvchi indekslar bir xil
Faqat bitta indeks bor
Elementlar joyi oâ€˜zgarmaydi

+++++
Stekni massiv yordamida tasvirlashda asosiy operatsiya nima?
# Elementni oxirgi joyga qoâ€˜shish va olib tashlash
Elementlarni tasodifiy almashtirish
Elementlarni boshlangâ€˜ich joyga qoâ€˜shish
Elementlarni oâ€˜chirib turish

+++++
Chiziqli bogâ€˜langan roâ€˜yhat yordamida navbat qanday tashkil qilinadi?
# Har bir tugun keyingi tugunga pointer orqali bogâ€˜langan
Tugunlar teskari bogâ€˜langan
Elementlar massivda saqlanadi
Xesh funktsiyasi bilan bogâ€˜lanadi

+++++
Stekda yangi elementni qoâ€˜shish operatsiyasi nima deb ataladi?
# Push
Pop
Enqueue
Dequeue

+++++
Stekdan elementni chiqarish operatsiyasi nima deb ataladi?
# Pop
Push
Insert
Remove

+++++
Navbatda element qoâ€˜shish operatsiyasi qanday ataladi?
# Enqueue
Push
Pop
Delete

+++++
Navbatdan element chiqarish operatsiyasi qanday ataladi?
# Dequeue
Pop
Push
Insert

+++++
Dek tuzilmasida element qoâ€˜shishning nechta varianti bor?
# Ikkita â€” boshidan va oxiridan
Faqat bitta â€” boshidan
Faqat bitta â€” oxiridan
Uchta

+++++
Chiziqli bogâ€˜langan roâ€˜yhat yordamida stekni yaratishda qaysi tugun qoâ€˜shiladi?
# Boshiga yangi tugun
Oxiriga yangi tugun
Tasodifiy joyga
Xesh jadvalga

+++++
Massiv yordamida navbatda oâ€˜chirish operatsiyasining murakkabligi qanday?
# O(1)
O(n)
O(log n)
O(n log n)

+++++
Massiv yordamida stekda qoâ€˜shish va oâ€˜chirish operatsiyalarining murakkabligi nima?
# O(1)
O(n)
O(log n)
O(n^2)

+++++
Dekni chiziqli bogâ€˜langan roâ€˜yhat yordamida ifodalashda nima qoâ€˜shiladi?
# Har bir tugunga oldingi va keyingi pointerlar
Faqat keyingi pointerlar
Faqat oldingi pointerlar
Pointerlar yoâ€˜q

+++++
Navbat va stek orasidagi asosiy farq nima?
# Navbat FIFO, stek LIFO printsipida ishlaydi
Navbat elementlarni oâ€˜chiradi, stek esa qoâ€˜shadi
Ikkalasi ham faqat massivda ishlaydi
Ikkalasi ham faqat bogâ€˜langan roâ€˜yhatda ishlaydi

+++++
Stek va navbatni qaysi sohada koâ€˜p qoâ€˜llaniladi?
# Algoritmlarda va operatsion tizimlarda
Faqat grafikalar uchun
Matematikada emas
Faqat fayl tizimida

+++++
Massiv yordamida navbatning asosiy kamchiligi nima?
# Boâ€˜sh joydan unumli foydalanmasligi
Elementlarni teskari joylashishi
Maâ€™lumotlarni oâ€˜chirish qiyinligi
Pointerlar yoâ€˜qligi

+++++
Chiziqli bogâ€˜langan roâ€˜yhat yordamida stek yaratish afzalligi nima?
# Dinamik xotira ishlatish va oâ€˜lchamini oâ€˜zgartirish imkoniyati
Massivlar bilan taqqoslaganda tezligi past
Faqat matnli maâ€™lumotlar uchun
Faqat grafikalar uchun
+++++
Ustivor navbat (Priority Queue) qanday ishlaydi?
# Har doim eng yuqori ustivorga ega element birinchi olinadi
FIFO printsipida ishlaydi
LIFO printsipida ishlaydi
Elementlar tasodifiy olinadi

+++++
Navbat va ustivor navbat orasidagi farq nima?
# Ustivor navbatda elementlar ustivorga koâ€˜ra chiqariladi
Navbatda elementlar tasodifiy olinadi
Navbat LIFO, ustivor FIFO printsipida ishlaydi
Ustivor navbat faqat matnli maâ€™lumotlarni saqlaydi

+++++
Lugâ€˜at (Dictionary) nima?
# Kalit-qiymat juftliklarini saqlovchi maâ€™lumotlar tuzilmasi
Faqat raqamlarni saqlaydi
Faqat ketma-ket massivdir
Faqat xesh funktsiyasidan iborat

+++++
Lugâ€˜atni qanday maâ€™lumotlar tuzilmasi yordamida amalga oshirish mumkin?
# Hash jadval yordamida
Massivning boshida
Chiziqli bogâ€˜langan roâ€˜yhatda
Ikki bogâ€˜lamli roâ€˜yhatda

+++++
Chiziqli konteynerlar qaysilar?
# Roâ€˜yhat, stek, navbat va dek
Graf, daraxt, xesh jadval
Fayl tizimi, operatsion tizim
HTML va CSS

+++++
Iterator nima?
# Maâ€™lumotlar tuzilmasidagi elementlarga ketma-ket kirishni taâ€™minlovchi obyekt
Yangi maâ€™lumot qoâ€˜shuvchi funksiyalar
Elementlarni oâ€˜chiruvchi algoritm
Maâ€™lumotlarni saralovchi qism

+++++
Iteratorning asosiy vazifasi nima?
# Maâ€™lumotlar tuzilmasida harakatlanish
Yangi maâ€™lumot yaratish
Foydalanuvchi interfeysini yaratish
Xotirani boshqarish

+++++
Ustivor navbatda element qoâ€˜shish operatsiyasi qanday nomlanadi?
# Insert yoki Enqueue with priority
Push
Pop
Dequeue

+++++
Iteratorlarning qaysi turi elementlarga faqat oldinga qarab harakatlanadi?
# Forward iterator
Bidirectional iterator
Random access iterator
Reverse iterator

+++++
Random access iterator qaysi maâ€™lumotlar tuzilmasida keng qoâ€˜llanadi?
# Massiv va vektor kabi kontynerlarda
Bogâ€˜langan roâ€˜yhatda
Hash jadvalda
Fayllarda

+++++
Stek, navbat va dek qanday chiziqli konteynerlardir?
# Maâ€™lumotlar ketma-ketligi bilan ishlaydi
Grafga oâ€˜xshash
Daraxtlar bilan ishlaydi
Tasodifiy maâ€™lumotlarni saqlaydi

+++++
Ustivor navbatni amalga oshirish uchun qaysi tuzilma koâ€˜pincha ishlatiladi?
# Ikkilik heap (binary heap)
Ikkilik daraxt
Chiziqli roâ€˜yhat
Matritsa

+++++
Lugâ€˜atda kalit boâ€˜yicha qiymat qidirish qanday murakkablikda boâ€˜ladi?
# O(1) (hash jadvalda)
O(n^2)
O(log n)
O(n)

+++++
Dekda element qoâ€˜shish va oâ€˜chirish operatsiyalari qayerdan amalga oshirilishi mumkin?
# Ikkala tomonidan ham
Faqat boshidan
Faqat oxiridan
Faqat oâ€˜rtadan

+++++
Iteratorning bidirectional turi nimani taâ€™minlaydi?
# Oldinga va orqaga harakatlanishni
Faqat oldinga harakatlanishni
Faqat tasodifiy kirishni
Faqat orqaga harakatlanishni

+++++
Iteratorlar qaysi dasturlash tillarida keng qoâ€˜llaniladi?
# C++, Java, Python va boshqalar
Faqat C tilida
Faqat HTMLda
Faqat SQLda

+++++
Navbatni chiziqli bogâ€˜langan roâ€˜yhat yordamida amalga oshirishda qanday koâ€˜rsatkichlar kerak?
# Bosh va oxir koâ€˜rsatkichlari
Faqat bosh koâ€˜rsatkich
Faqat oxir koâ€˜rsatkich
Koâ€˜rsatkichlar kerak emas

+++++
Stekda eng oxirgi qoâ€˜shilgan elementni olish uchun qanday operatsiya ishlatiladi?
# Pop
Push
Enqueue
Dequeue

+++++
Lugâ€˜atdagi kalit topilmasa nima sodir boâ€˜ladi?
# Xatolik yoki null qiymat qaytariladi
Doim yangi kalit qoâ€˜shiladi
Qiymat avtomatik oâ€˜zgartiriladi
Hech narsa sodir boâ€˜lmaydi

+++++
Iterator yordamida maâ€™lumotlar ustida qanday amallarni bajarish mumkin?
# Koâ€˜rish, oâ€˜zgartirish, harakatlanish
Faqat oâ€˜chirish
Faqat qoâ€˜shish
Faqat yangi roâ€˜yhat yaratish
+++++
Daraxt (Tree) maâ€™lumotlar tuzilmasi nima?
# Tugunlar (node) va ularning ota-ona (parent) va bolalar (child) munosabatlarini ifodalovchi ierarxik struktura
Faqat ketma-ket massiv
Faqat graflar yigâ€˜indisi
Faqat matnli maâ€™lumotlar roâ€˜yxati

+++++
Daraxtda ildiz (root) tugun nima?
# Daraxtning eng yuqori darajadagi yagona tuguni
Har bir tugun uchun oxirgi bola
Faqat barg tugunlari
Tugunlar orasidagi bogâ€˜lanish

+++++
Daraxtda barg (leaf) tugun nima?
# Hech qanday bolasi boâ€˜lmagan tugun
Har bir tugun uchun ota-ona
Faqat ildiz tugun
Faqat bitta bola boâ€˜lgan tugun

+++++
Daraxtning chuqurligi nima?
# Ildizdan eng chuqur barggacha boâ€˜lgan yoâ€˜l uzunligi
Faqat ildiz tugunning balandligi
Har bir tugun soni
Tugunlar orasidagi masofa

+++++
Binarny daraxt nima?
# Har bir tugunning eng koâ€˜p ikkita bolasi bor
Har bir tugunning faqat bitta bolasi bor
Har bir tugun uchta bola bilan
Tugunlar ketma-ket massivda joylashgan

+++++
Toâ€˜liq binarny daraxtda nechta bola bor?
# Har bir tugun 0 yoki 2 bolaga ega
Har bir tugun faqat bitta bola
Faqat ildiz tugun bola
Hech qanday bola yoâ€˜q

+++++
Daraxtda otaning darajasi nimani bildiradi?
# Tugunning nechta bolasi borligini
Tugunning ildizga masofasi
Tugunning umumiy soni
Tugunning boâ€˜yi

+++++
Daraxt koâ€˜ruvi (Traversal) nima?
# Daraxtdagi barcha tugunlarni tartib bilan koâ€˜rish jarayoni
Faqat ildiz tugunni koâ€˜rish
Faqat barglarni koâ€˜rish
Elementlarni oâ€˜chirish

+++++
Daraxtning pre-order koâ€˜ruvi qanday ishlaydi?
# Ildiz, chap bola, oâ€˜ng bola tartibida
Chap bola, ildiz, oâ€˜ng bola
Barglardan boshlab yuqoriga
Faqat barglarni

+++++
Daraxtning in-order koâ€˜ruvi qanday ishlaydi?
# Chap bola, ildiz, oâ€˜ng bola tartibida
Ildiz, oâ€˜ng bola, chap bola
Faqat ildiz tugunni
Faqat barglarni

+++++
Daraxtning post-order koâ€˜ruvi qanday ishlaydi?
# Chap bola, oâ€˜ng bola, ildiz tartibida
Ildiz, chap bola, oâ€˜ng bola
Faqat ildiz
Faqat barglar

+++++
Graf va daraxt orasidagi asosiy farq nima?
# Daraxtda sikl (aylana) boâ€˜lmaydi
Grafda faqat bitta ildiz bor
Daraxtda elementlar ketma-ket saqlanadi
Grafda faqat ikki tugun bor

+++++
Balanslangan daraxt nimani anglatadi?
# Daraxtning chap va oâ€˜ng subdaraxtlari balansi saqlangan
Faqat ildiz tugun bor
Faqat barglar mavjud
Tugunlar bitta yoâ€˜lda joylashgan

+++++
AVL daraxt nima?
# Balanslangan ikkilik qidiruv daraxti
Faqat ketma-ket massiv
Grafning turli turi
Daraxtning barglari

+++++
Binarny qidiruv daraxt (BST) qanday ishlaydi?
# Chap bolalar ildizdan kichik, oâ€˜ng bolalar katta qiymatga ega
Har doim toâ€˜liq binarny daraxt
Faqat chap bolalar katta
Barchasi teng

+++++
Daraxtda chuqurlikni qanday hisoblash mumkin?
# Ildizdan eng uzoq barggacha boâ€˜lgan yoâ€˜l uzunligi
Faqat ildiz tugunni hisoblash
Faqat barglarni hisoblash
Har bir tugunni sanash

+++++
Daraxtni chiziqli tarzda qanday koâ€˜rish mumkin?
# Traversal yordamida
Faqat grafik koâ€˜rinishda
Matritsada
Tasodifiy

+++++
Daraxtda sikl (aylana) paydo boâ€˜lsa, u nima boâ€˜ladi?
# Daraxt boâ€˜lmaydi, grafikga aylanadi
Yangi daraxt hosil boâ€˜ladi
Elementlar koâ€˜payadi
Hech narsa oâ€˜zgaradi

+++++
Daraxtlarda qaysi operatsiya tezkor qidiruvni taâ€™minlaydi?
# Binarny qidiruv daraxtlari
Oddiy bogâ€˜langan roâ€˜yhatlar
Massiv
Graf

+++++
Daraxtda har bir tugunning darajasi nimani anglatadi?
# Tugunning bolalari soni
Tugunning ota-ona soni
Tugunning boâ€˜yi
Tugunning massivi
+++++
Binar qidiruv daraxtida (BST) chap bola qanday qiymatga ega boâ€˜ladi?
# Ildiz tugundan kichik qiymat
Ildiz tugundan katta qiymat
Ildiz bilan teng qiymat
Tasodifiy qiymat

+++++
Binar qidiruv daraxtida element qidiruv qanday amalga oshiriladi?
# Har bir tugunda kalit ildiz bilan solishtiriladi va chap yoki oâ€˜ng subdaraxtga oâ€˜tiladi
Faqat ildizda qidiriladi
Faqat barglarda qidiriladi
Tasodifiy joylarda

+++++
Binar qidiruv daraxtida element qoâ€˜shish qanday amalga oshiriladi?
# Qidiruv orqali joy topilib, yangi tugun qoâ€˜shiladi
Har doim ildizga qoâ€˜shiladi
Faqat barglarga qoâ€˜shiladi
Element almashtiriladi

+++++
Binar qidiruv daraxtidan element oâ€˜chirishda uchta holat bor, ularni sanang:
# Barg tugun, bitta bola, ikki bola
Faqat bitta bola
Faqat barg tugun
Faqat ildiz tugun

+++++
Muvozanatlangan binar qidiruv daraxti nima?
# Daraxtning chap va oâ€˜ng subdaraxtlari balansi saqlangan daraxt
Faqat ildiz mavjud daraxt
Faqat bitta bola bor
Hech qanday bola yoâ€˜q

+++++
AVL daraxti nimaga asoslangan?
# Har bir tugunning chap va oâ€˜ng subdaraxt balansi -1, 0 yoki +1 boâ€˜lishi kerak
Faqat barglar balansi
Faqat ildiz balansi
Tasodifiy qiymatlar

+++++
AVL daraxtida muvozanatni saqlash uchun qanday operatsiyalar qoâ€˜llaniladi?
# Burilishlar (rotatsiyalar)
Elementlarni oâ€˜chirish
Faol koâ€˜chiruvlar
Elementlarni almashtirish

+++++
Binar qidiruv daraxtida elementni qidirishning eng yaxshi vaqt murakkabligi qanday?
# O(log n)
O(n)
O(n log n)
O(1)

+++++
Binar qidiruv daraxtining eng yomon holatdagi murakkabligi qanday?
# O(n)
O(log n)
O(n log n)
O(1)

+++++
AVL daraxtida oâ€˜ng burilish (right rotation) nima uchun ishlatiladi?
# Chap subdaraxt juda chuqur boâ€˜lganda muvozanatni tiklash uchun
Oâ€˜ng subdaraxtni koâ€˜paytirish uchun
Element qoâ€˜shish uchun
Element oâ€˜chirish uchun

+++++
AVL daraxtida chap burilish (left rotation) nima vazifani bajaradi?
# Oâ€˜ng subdaraxt juda chuqur boâ€˜lganda muvozanatni tiklash
Chap subdaraxtni koâ€˜paytirish
Elementlarni almashtirish
Boshqa daraxtga koâ€˜chirish

+++++
Binar qidiruv daraxtiga yangi elementni qoâ€˜shishdan keyin nimani tekshirish kerak?
# Daraxtning muvozanati
Faqat ildiz tugunni
Faqat barglarni
Hech narsani

+++++
Element oâ€˜chirishda agar oâ€˜chirilayotgan tugun ikki bolaga ega boâ€˜lsa, nima qilinadi?
# Oâ€˜chiriladigan tugun oâ€˜rniga oâ€˜ng subdaraxtdagi eng kichik element olinadi
Element oâ€˜chirilib ketadi
Faqat chap subdaraxt koâ€˜chiriladi
Hech narsa qilinmaydi

+++++
Binar qidiruv daraxtida elementni qidirishda qaysi holatda barcha tugunlar tekshiriladi?
# Daraxt chiziqli (muvozanatsiz) boâ€˜lsa
Har doim
Hech qachon
Faqat ildizda

+++++
AVL daraxti qaysi holatda muvozanatni tiklash uchun ikki burilish amalga oshiriladi?
# Chap-oâ€˜ng yoki oâ€˜ng-chap holatlarida
Faqat chap chap
Faqat oâ€˜ng oâ€˜ng
Hech qachon

+++++
Binar qidiruv daraxtining qaysi xususiyati qidiruvni samarali qiladi?
# Chap subdaraxtdagi barcha elementlar ildizdan kichik, oâ€˜ngdagilar katta
Tugunlarning tartibsizligi
Faqat ildizda element boâ€˜lishi
Elementlar ketma-ketligi

+++++
Binar qidiruv daraxtida oâ€˜chirishdan keyin nimani bajarish kerak?
# Muvozanatni tekshirish va zarur boâ€˜lsa burilishlar qilish
Faqat ildizni oâ€˜zgartirish
Element qoâ€˜shish
Hech narsa

+++++
Muvozanatlangan binar daraxtlar qaysi algoritmlar samaradorligini oshiradi?
# Qidiruv, qoâ€˜shish va oâ€˜chirish
Faqat qidiruv
Faqat qoâ€˜shish
Faqat oâ€˜chirish

+++++
Binar qidiruv daraxtining balansi buzilganda nimani bajarish kerak?
# Burilishlar yordamida muvozanatni tiklash
Elementlarni almashtirish
Elementlarni oâ€˜chirish
Hech narsani qilmaslik
+++++
Heap daraxti nima?
# Maxsus binar daraxt boâ€˜lib, har bir ota-ona tugun bolalaridan katta (yoki kichik) qiymatga ega
Oddiy binar daraxt
Faqat toâ€˜liq binar daraxt
Ierarxik graflar yigâ€˜indisi

+++++
Max-heap nima?
# Har bir ota-ona bolalaridan katta yoki teng qiymatga ega boâ€˜lgan heap
Har bir ota-ona bolalaridan kichik qiymatga ega
Faqat barglar katta
Faqat ildiz kichik

+++++
Min-heap nima?
# Har bir ota-ona bolalaridan kichik yoki teng qiymatga ega boâ€˜lgan heap
Har bir ota-ona bolalaridan katta qiymatga ega
Faqat barglar kichik
Faqat ildiz katta

+++++
Heap daraxti qanday koâ€˜rinishda tashkil etiladi?
# Toâ€˜liq binar daraxt koâ€˜rinishida
Tasodifiy daraxt
Faqat chap yonlama daraxt
Faqat oâ€˜ng yonlama daraxt

+++++
Heapni massiv yordamida qanday ifodalash mumkin?
# Elementlar ketma-ket joylashgan massivda ota-ona va bolalar indekslari hisoblanadi
Har bir element alohida massivda
Faqat bitta massivda ildiz
Massivda faqat barglar

+++++
Heapda ota-onaning chap bolasi indeksini massivda qanday topamiz?
# 2*i + 1
i - 1
i / 2
2*i

+++++
Heapda ota-onaning oâ€˜ng bolasi indeksini massivda qanday topamiz?
# 2*i + 2
i + 1
i * 3
2*i - 1

+++++
Heapda ota-ona tugun indeksini massivda qanday topamiz?
# (i - 1) // 2
i + 1
i * 2
2*i + 1

+++++
Heap tuzilmasida qoâ€˜shish (insert) amali qanday bajariladi?
# Yangi element oxiriga qoâ€˜yilib, yuqoriga burilishlar orqali joylashadi
Faqat oxiriga qoâ€˜yiladi
Faqat boshidan qoâ€˜yiladi
Element almashtiriladi

+++++
Heapda oâ€˜chirish (delete) amali qaysi tugunni oâ€˜chiradi odatda?
# Ildiz tugunni
Oxirgi tugunni
Oâ€˜ng bolani
Chap bolani

+++++
Heapda oâ€˜chirishdan keyin nimani bajarish kerak?
# Pastga burilish (heapify) qilib muvozanatni tiklash
Element qoâ€˜shish
Hech narsa
Massivni tozalash

+++++
Heapify algoritmi nima uchun ishlatiladi?
# Daraxtda heap xususiyatini tiklash uchun
Elementlarni oâ€˜chirish uchun
Faqat massivni yaratish uchun
Tugunlarni almashtirish uchun

+++++
Heapni tashkil etishning tezkor usuli qaysi?
# Bottom-up (pastdan yuqoriga) heapify
Top-down
Tasodifiy qoâ€˜shish
Faqat oâ€˜chirish

+++++
Heapda maksimal qiymat qaerda joylashgan boâ€˜ladi?
# Ildizda (max-heap uchun)
Barglarda
Oxirida
Chap bolada

+++++
Heapda minimal qiymat qaerda joylashgan boâ€˜ladi?
# Ildizda (min-heap uchun)
Barglarda
Oxirida
Chap bolada

+++++
Heapda yangi element qoâ€˜shishning vaqt murakkabligi qancha?
# O(log n)
O(n)
O(1)
O(n log n)

+++++
Heapda maksimal qiymatni olish qanday amalga oshiriladi?
# Ildizdagi elementni olish
Oxirgi elementni olish
Barglardan qidirish
Tasodifiy elementni olish

+++++
Heapda elementlarni saralash uchun qaysi algoritm ishlatiladi?
# Heapsort
Bubblesort
Quicksort
Mergesort

+++++
Heapda oâ€˜chirishdan keyin heap xususiyatini tiklash uchun qanday amal bajariladi?
# Heapify (pastga burilish)
Element qoâ€˜shish
Oâ€˜ng burilish
Chap burilish

+++++
Heapdagi elementlarni qanday koâ€˜rish mumkin?
# Traversal yordamida yoki massiv koâ€˜rinishida
Faqat barglar
Faqat ildiz
Faqat tasodifiy
+++++
Graf nima?
# Tugunlar va ularni bogâ€˜lovchi yoylardan iborat toâ€˜plam
Faqat tugunlar yigâ€˜indisi
Faqat yoylar yigâ€˜indisi
Ierarxik daraxt

+++++
Qoâ€˜shma matrisa nimani ifodalaydi?
# Graflardagi tugunlar orasidagi bogâ€˜lanishni ifodalovchi kvadrat matrisa
Faqat tugunlar roâ€˜yxati
Faqat yoylar roâ€˜yxati
Grafning ogâ€˜irligini

+++++
MunĞ¾sabatlar matrisasi nima?
# Grafdagi tugunlar orasidagi bogâ€˜lanishlarni 0 va 1 orqali ifodalaydi
Faqat ogâ€˜irliklar
Faqat tugunlar soni
Faqat yoylar uzunligi

+++++
Qoâ€˜shnilik roâ€˜yxati nimani ifodalaydi?
# Har bir tugun uchun unga qoâ€˜shnilar roâ€˜yxati
Faqat tugunlarning tartibini
Faqat yoylar uzunligini
Faqat ogâ€˜irliklarni

+++++
Yoylar roâ€˜yxati nima?
# Grafdagi barcha yoylar roâ€˜yxati, ularning boshlanish va tugash tugunlari bilan
Faqat tugunlar roâ€˜yxati
Faqat bogâ€˜lanish darajasi
Faqat bitta tugun roâ€˜yxati

+++++
Qoâ€˜shma matrisaning oâ€˜lchami qanday boâ€˜ladi?
# n x n, bu yerda n â€” tugunlar soni
n x m, m â€” yoylar soni
2 x n
n x 1

+++++
Grafdagi qoâ€˜shnilik roâ€˜yxati qanday maâ€™lumotni saqlaydi?
# Har bir tugun uchun unga bevosita bogâ€˜langan tugunlar roâ€˜yxatini
Faqat yoylarning sonini
Faqat tugunlarning raqamlarini
Faqat muhim tugunlarni

+++++
Munosabatlar matrisasida 0 va 1 nimani anglatadi?
# 1 â€” bogâ€˜lanish bor, 0 â€” bogâ€˜lanish yoâ€˜q
1 â€” bogâ€˜lanish yoâ€˜q, 0 â€” bor
Faqat raqamlar
Faqat indekslar

+++++
Qoâ€˜shma matrisada simmetriya nimani anglatadi?
# Yoâ€˜nalmagan graf
Yoâ€˜nalgan graf
Birinchi element kichik
Elementlar teng emas

+++++
Yoylar roâ€˜yxati qaysi holat uchun qulayroq?
# Grafda yoylar soni kam boâ€˜lsa
Grafda tugunlar soni kam boâ€˜lsa
Faqat toâ€˜liq graflar uchun
Faqat ierarxik graflar uchun

+++++
Qoâ€˜shnilik roâ€˜yxatida tugunlar qanday tartibda berilgan?
# Har bir tugun uchun unga bogâ€˜langan tugunlarning roâ€˜yxati
Faqat katta tartibda
Faqat kichik tartibda
Tasodifiy tartibda

+++++
Yoâ€˜nalgan grafda munosabatlar matrisasi qanday boâ€˜ladi?
# Asimmetrik yoki simmetrik emas
Doim simmetrik
Doim asimmetrik
Faqat diagonal elementlari 1

+++++
Qoâ€˜shma matrisa qaysi holatda samaraliroq?
# Graf zich boâ€˜lsa (koâ€˜p yoylar mavjud boâ€˜lsa)
Graf kam yoyli boâ€˜lsa
Faqat yoâ€˜nalgan graflar uchun
Faqat yoâ€˜nalmagan graflar uchun

+++++
Qoâ€˜shnilik roâ€˜yxati qaysi holatda samaraliroq?
# Graf kam yoyli boâ€˜lsa (kam zich)
Graf zich boâ€˜lsa
Faqat yoâ€˜nalgan graflar uchun
Faqat yoâ€˜nalmagan graflar uchun

+++++
Grafdagi tugunlar sonini qanday belgilaymiz?
# n bilan
m bilan
k bilan
x bilan

+++++
Yoylar sonini qanday belgilaymiz?
# m bilan
n bilan
k bilan
x bilan

+++++
Grafning yoâ€˜nalgan yoki yoâ€˜nalmaganligini qaysi tasvir yordamida aniqlash mumkin?
# Qoâ€˜shma matrisaning simmetriyasidan
Tugunlar roâ€˜yxatidan
Yoylar roâ€˜yxatidan emas
Faqat barglardan

+++++
Grafda DFS algoritmi nima vazifani bajaradi?
# Grafikda chuqurlik boâ€˜yicha qidiruv
Bredth boâ€˜yicha qidiruv
Element qoâ€˜shish
Element oâ€˜chirish

+++++
Grafda BFS algoritmi nima vazifani bajaradi?
# Grafikda kenglik boâ€˜yicha qidiruv
Chuqurlik boâ€˜yicha qidiruv
Element qoâ€˜shish
Element oâ€˜chirish

+++++
Qoâ€˜shma matrisaning elementlari nimani koâ€˜rsatadi?
# I va j tugunlari orasidagi bogâ€˜lanishni
Faqat tugun nomi
Faqat ogâ€˜irlik
Faqat yoylar uzunligi
+++++
BFS algoritmi nima vazifani bajaradi?
# Grafda eniga qarab qidiruv
Grafda tubiga qarab qidiruv
Faqat element qoâ€˜shish
Faqat element oâ€˜chirish

+++++
DFS algoritmi nima vazifani bajaradi?
# Grafda tubiga qarab qidiruv
Grafda eniga qarab qidiruv
Elementlarni saralash
Elementlarni oâ€˜chirish

+++++
BFS algoritmida qaysi maâ€™lumot tuzilmasidan koâ€˜proq foydalaniladi?
# Navbat (queue)
Stek (stack)
Massiv
Bogâ€˜langan roâ€˜yxat

+++++
DFS algoritmida qaysi maâ€™lumot tuzilmasidan koâ€˜proq foydalaniladi?
# Stek (stack) yoki rekursiya
Navbat (queue)
Massiv
Bogâ€˜langan roâ€˜yxat

+++++
BFS qaysi holatlarda samaraliroq ishlaydi?
# Eng qisqa yoâ€˜lni topishda
Grafning chuqurligini oâ€˜lchashda
Faqat daraxtlar uchun
Faqat yoâ€˜nalgan graflar uchun

+++++
DFS algoritmi qaysi muammo uchun yaxshi yechim?
# Tsikllarni aniqlash va yoâ€˜l topishda
Eng qisqa yoâ€˜lni topishda
Faqat ierarxik daraxtlar uchun
Faqat bogâ€˜langan graflar uchun

+++++
BFS algoritmida boshlangâ€˜ich tugundan keyin qaysi tugunlar tashrif buyuriladi?
# Barcha qoâ€˜shni tugunlar birinchi navbatda
Faqat birinchi tugun
Faqat oxirgi tugun
Faqat ierarxik tugunlar

+++++
DFS algoritmida boshlangâ€˜ich tugundan keyin qaysi tugunlar tashrif buyuriladi?
# Eng chuqur qismga borilgunga qadar ketma-ket
Barcha qoâ€˜shni tugunlar birinchi navbatda
Faqat oxirgi tugun
Faqat ildiz tugun

+++++
BFS va DFS algoritmlarining asosiy farqi nimada?
# BFS eniga, DFS tubiga qarab qidiradi
BFS faqat rekursiya, DFS faqat stek bilan ishlaydi
DFS faqat massiv bilan, BFS faqat roâ€˜yxat bilan ishlaydi
Hech qanday farqi yoâ€˜q

+++++
BFS algoritmi uchun boshlangâ€˜ich tugun qanday tanlanadi?
# Foydalanuvchi yoki muammo tomonidan beriladi
Har doim 0
Faqat oxirgi tugun
Tasodifiy

+++++
DFS algoritmi uchun boshlangâ€˜ich tugun qanday tanlanadi?
# Foydalanuvchi yoki muammo tomonidan beriladi
Har doim 0
Faqat oxirgi tugun
Tasodifiy

+++++
BFS algoritmida tugunlar tashrifi qanday qayd etiladi?
# Maxsus belgilar (visited) yordamida
Hech qanday qayd etilmaydi
Faqat tugun nomi
Faqat oâ€˜chiriladi

+++++
DFS algoritmida tugunlar tashrifi qanday qayd etiladi?
# Maxsus belgilar (visited) yordamida
Hech qanday qayd etilmaydi
Faqat tugun nomi
Faqat oâ€˜chiriladi

+++++
DFS algoritmi uchun rekursiya qanday ishlaydi?
# Har bir tugun uchun uning qoâ€˜shnilariga chuqurroq kirish
Faqat tugun qoâ€˜shish
Faqat tugun oâ€˜chirish
Faqat massiv yaratish

+++++
BFS va DFS algoritmlarining murakkabligi qanday?
# O(V + E), bu yerda V â€” tugunlar, E â€” yoylar soni
O(V^2)
O(E^2)
O(1)

+++++
DFS algoritmi qaysi maâ€™lumot tuzilmasi yordamida amalga oshiriladi?
# Stek yoki rekursiv chaqiriqlar
Navbat
Massiv
Bogâ€˜langan roâ€˜yxat

+++++
BFS algoritmi qaysi sohalarda qoâ€˜llaniladi?
# Tarmoq qidiruvlari, eng qisqa yoâ€˜l topish
Faqat matematikada
Faqat rasm ishlashda
Faqat fayl tizimida

+++++
DFS algoritmi qaysi sohalarda qoâ€˜llaniladi?
# Tsikl aniqlash, komponentlarni ajratish
Faqat tarmoqda
Faqat grafik chizishda
Faqat fayl tizimida

+++++
DFS algoritmida qayta tashrif buyurilmaslik uchun nima qilinadi?
# Tashrif buyurilgan tugunlar belgilanadi
Har doim qayta tashrif buyuriladi
Faqat tugun nomlari yoziladi
Hech narsa qilinmaydi
+++++
Graflarda eng qisqa yoâ€˜lni aniqlash vazifasi nima?
# Tugunlar orasidagi eng qisqa yoâ€˜lni topish
Faqat tugunlarni sanash
Faqat yoylarni oâ€˜chirish
Faqat grafni chizish

+++++
Deykstra algoritmi qanday graflar uchun moâ€˜ljallangan?
# Ogâ€˜irliklari manfiy boâ€˜lmagan yoâ€˜nalgan graflar
Faqat manfiy ogâ€˜irlikli graflar
Faqat yoâ€˜nalmagan graflar
Faqat ierarxik daraxtlar

+++++
Ford-Bellman algoritmi qaysi holatlarda ishlaydi?
# Manfiy ogâ€˜irliklarga ega boâ€˜lgan graflarda ham
Faqat manfiy ogâ€˜irliksiz graflarda
Faqat yogâ€˜och daraxtlarda
Faqat ierarxik graflarda

+++++
Floyd-Warshall algoritmi nima vazifani bajaradi?
# Barcha tugunlar orasidagi eng qisqa yoâ€˜llarni topish
Faqat boshlangâ€˜ichdan bitta tugungacha yoâ€˜lni topish
Faqat oxirgi tugunga yoâ€˜l topish
Faqat qisqa yoylarni sanash

+++++
Deykstra algoritmi qanday usul asosida ishlaydi?
# Eng qisqa masofani asta-sekin yangilab boradi
Tasodifiy qidiruv
Faqat rekursiya
Faqat stek yordamida

+++++
Ford-Bellman algoritmi qanday usulga asoslangan?
# Har bir yoyni takroran yangilab borish (relaksatsiya)
Tasodifiy qidiruv
Faqat massiv bilan ishlash
Faqat stek bilan ishlash

+++++
Floyd-Warshall algoritmi murakkabligi qanday?
# O(n^3), n â€” tugunlar soni
O(n)
O(log n)
O(n!)

+++++
Deykstra algoritmining murakkabligi qanday?
# O((V + E) log V), V â€” tugunlar, E â€” yoylar soni
O(V)
O(E^2)
O(1)

+++++
Ford-Bellman algoritmining murakkabligi qanday?
# O(V * E)
O(V + E)
O(log V)
O(V^2)

+++++
Floyd-Warshall algoritmi qaysi turdagi graflar uchun qoâ€˜llaniladi?
# Yoâ€˜nalgan va yoâ€˜nalmagan graflar uchun
Faqat yoâ€˜nalgan graflar uchun
Faqat yoâ€˜nalmagan graflar uchun
Faqat ierarxik daraxtlar uchun

+++++
Deykstra algoritmi qaysi maâ€™lumot tuzilmasidan foydalanadi?
# Minimal ustuvor navbat (priority queue)
Oddiy navbat (queue)
Stek (stack)
Massiv

+++++
Ford-Bellman algoritmi qanday holatlarda xatolik yuzaga keladi?
# Manfiy sikllar mavjud boâ€˜lsa
Faqat katta graflarda
Faqat kichik graflarda
Faqat yoâ€˜nalgan graflarda

+++++
Floyd-Warshall algoritmi qanday printsip asosida ishlaydi?
# Dynamic programming
Greedy
Divide and conquer
Tasodifiy qidiruv

+++++
Deykstra algoritmi qanday vaziyatda notoâ€˜gâ€˜ri natija beradi?
# Grafda manfiy ogâ€˜irliklar boâ€˜lsa
Faqat kichik graflarda
Faqat katta graflarda
Faqat yoâ€˜nalgan graflarda

+++++
Ford-Bellman algoritmi qanday natija beradi?
# Har bir tugunga eng qisqa masofani
Faqat boshlangâ€˜ich tugunga
Faqat oxirgi tugunga
Faqat yoylarga

+++++
Floyd-Warshall algoritmi qanday natija beradi?
# Barcha tugunlar orasidagi eng qisqa yoâ€˜llar matrisi
Faqat boshlangâ€˜ich tugunlar
Faqat oxirgi tugunlar
Faqat bogâ€˜lanishlar soni

+++++
Deykstra algoritmi qaysi holatda samaraliroq?
# Graf zich boâ€˜lmasa va manfiy ogâ€˜irliklarsiz boâ€˜lsa
Faqat manfiy ogâ€˜irliklarda
Faqat ierarxik daraxtlarda
Faqat katta sikllarda

+++++
Ford-Bellman algoritmida nechta iteratsiya bajariladi?
# Tugunlar sonidan bitta kam
Hech qachon iteratsiya qilinmaydi
Cheksiz
Faqat bittagina

+++++
Floyd-Warshall algoritmida asosiy sikl nechta marta ishlaydi?
# Uch marta: har bir tugun uchun uch marta aylantiriladi
Bir marta
Ikki marta
Toâ€˜rt marta

+++++
Eng qisqa yoâ€˜lni aniqlashda Deykstra algoritmida boshlangâ€˜ich tugun qanday tanlanadi?
# Foydalanuvchi tomonidan belgilanadi
Har doim 0
Tasodifiy
Faqat oxirgi tugun

+++++
Ford-Bellman algoritmi qanday holatda samaraliroq?
# Manfiy ogâ€˜irlikli yoylar boâ€˜lsa
Faqat musbat ogâ€˜irliklarda
Faqat siklsiz graflarda
Faqat kichik graflarda

+++++
Floyd-Warshall algoritmida manfiy sikllarni aniqlash mumkinmi?
# Ha, diagonal elementlar manfiy boâ€˜lsa sikl bor
Yoâ€˜q
Faqat Deykstra algoritmida mumkin
Faqat Ford-Bellman algoritmida mumkin

+++++
Deykstra algoritmi qaysi maâ€™lumotlar tuzilmasi yordamida tezlashtiriladi?
# Minimal ustuvor navbat (priority queue)
Oddiy massiv
Stek
Oddiy navbat

+++++
Eng qisqa yoâ€˜lni aniqlash algoritmlaridan qaysi biri barcha tugunlar orasidagi masofani aniqlaydi?
# Floyd-Warshall
Deykstra
Ford-Bellman
BFS

`;

        let allQuestions = [];
        let currentQuestions = [];
        let currentQuestionIndex = 0;
        let score = 0;
        let timer;
        let timeLeft = 30;
        let answered = false;
        let testCount = 0;

        // Savollarni parse qilish - TO'G'RI JAVOBNI ANIQLASH
        function parseQuestions(content) {
            const blocks = content.split('+++++').filter(block => block.trim() !== '');
            blocks.forEach(block => {
                const lines = block.trim().split('\n');
                if (lines.length > 1) {
                    const questionText = lines[0];
                    const answers = [];
                    let correctAnswerText = null;
                    
                    // Avval to'g'ri javobni topamiz
                    for (let i = 1; i < lines.length; i++) {
                        if (lines[i].startsWith('#')) {
                            correctAnswerText = lines[i].substring(1).trim();
                            break;
                        }
                    }
                    
                    // Barcha javoblarni yig'amiz
                    for (let i = 1; i < lines.length; i++) {
                        if (lines[i].trim() === '') continue;
                        
                        const answerText = lines[i].startsWith('#') 
                            ? lines[i].substring(1).trim() 
                            : lines[i].trim();
                            
                        answers.push({
                            text: answerText,
                            correct: answerText === correctAnswerText
                        });
                    }
                    
                    if (answers.length > 0 && correctAnswerText) {
                        allQuestions.push({ 
                            question: questionText, 
                            answers: shuffleArray(answers),
                            correctAnswerText: correctAnswerText
                        });
                    }
                }
            });
        }

        // Massivni aralashtirish
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Dasturni boshlash
        function initTest() {
            parseQuestions(fileContent);
            currentQuestions = shuffleArray([...allQuestions]).slice(0, 50);
            startTest();
        }

        // Testni boshlash
        function startTest() {
            document.querySelector('.start-page').style.display = 'none';
            document.getElementById('testContainer').style.display = 'block';
            currentQuestionIndex = 0;
            score = 0;
            testCount = 0;
            showQuestion();
        }

        // Savolni ko'rsatish
        function showQuestion() {
            if (currentQuestionIndex >= currentQuestions.length) {
                endTest();
                return;
            }
            
            answered = false;
            timeLeft = 30;
            updateTimerDisplay();
            
            const question = currentQuestions[currentQuestionIndex];
            document.getElementById('questionText').innerHTML = question.question;
            document.getElementById('progress').textContent = `Savol: ${currentQuestionIndex + 1}/${currentQuestions.length}`;
            
            const optionsContainer = document.getElementById('optionsContainer');
            optionsContainer.innerHTML = '';
            
            question.answers.forEach((answer, index) => {
                const label = document.createElement('label');
                label.innerHTML = `
                    <input type="radio" name="question" value="${index}">
                    ${answer.text}
                `;
                optionsContainer.appendChild(label);
            });
            
            // Radio tugmalariga event listener qo'shamiz
            document.querySelectorAll('#optionsContainer input[type="radio"]').forEach((radio, index) => {
                radio.addEventListener('change', () => {
                    checkAnswer(index, question.correctAnswerText, question.answers);
                });
            });
            
            startTimer();
        }

        // Taymerni boshlash
        function startTimer() {
            clearInterval(timer);
            timer = setInterval(() => {
                timeLeft--;
                updateTimerDisplay();
                
                if (timeLeft <= 0 && !answered) {
                    clearInterval(timer);
                    const question = currentQuestions[currentQuestionIndex];
                    showCorrectAnswer(question.correctAnswerText, question.answers);
                    moveToNextQuestion();
                }
            }, 1000);
        }

        // Taymerni yangilash
        function updateTimerDisplay() {
            document.getElementById('time').textContent = timeLeft;
            const percentage = (timeLeft / 30) * 100;
            document.getElementById('timerBar').style.width = `${percentage}%`;
            
            const timerBar = document.getElementById('timerBar');
            if (timeLeft <= 10) {
                timerBar.style.backgroundColor = '#f44336';
            } else if (timeLeft <= 20) {
                timerBar.style.backgroundColor = '#FF9800';
            } else {
                timerBar.style.backgroundColor = '#4CAF50';
            }
        }

        // Javobni tekshirish
        function checkAnswer(selectedIndex, correctAnswerText, answers) {
            if (answered) return;
            answered = true;
            clearInterval(timer);
            
            const selectedAnswer = answers[selectedIndex];
            const isCorrect = selectedAnswer.text === correctAnswerText;
            
            if (isCorrect) {
                score++;
            }
            
            // Barcha javoblarni ko'rsatish
            const options = document.querySelectorAll('#optionsContainer label');
            options.forEach((label, index) => {
                const answer = answers[index];
                if (answer.text === correctAnswerText) {
                    label.classList.add('correct');
                } else if (index === selectedIndex && !isCorrect) {
                    label.classList.add('incorrect');
                }
            });
            
            moveToNextQuestion();
        }

        // To'g'ri javobni ko'rsatish (vaqt tugaganda)
        function showCorrectAnswer(correctAnswerText, answers) {
            const options = document.querySelectorAll('#optionsContainer label');
            options.forEach((label, index) => {
                if (answers[index].text === correctAnswerText) {
                    label.classList.add('correct');
                }
            });
        }

        // Keyingi savolga o'tish
        function moveToNextQuestion() {
            setTimeout(() => {
                currentQuestionIndex++;
                testCount++;
                
                if (testCount % 50 === 0 && testCount > 0) {
                    showIntermediateResult();
                } else {
                    showQuestion();
                }
            }, 3000);
        }

        // Oraliq natija
        function showIntermediateResult() {
            document.getElementById('questionText').textContent = '';
            document.getElementById('optionsContainer').innerHTML = '';
            document.getElementById('result').innerHTML = `
                <h2>Oraliq Natija</h2>
                <p>Siz ${score} ta savoldan to'g'ri javob berdingiz!</p>
                <p>Foizda: ${Math.round((score / 50) * 100)}%</p>
            `;
            
            setTimeout(() => {
                document.getElementById('result').innerHTML = '';
                showQuestion();
            }, 5000);
        }

        // Testni tugatish
        function endTest() {
            document.getElementById('questionText').textContent = '';
            document.getElementById('optionsContainer').innerHTML = '';
            document.getElementById('result').innerHTML = `
                <h2>Test Yakunlandi!</h2>
                <p>Umumiy natija: ${score} ta savoldan to'g'ri javob berdingiz!</p>
                <p>Foizda: ${Math.round((score / currentQuestions.length) * 100)}%</p>
                <button class="btn btn-restart" onclick="restartTest()">Qaytadan Boshlash</button>
                <button class="btn" onclick="location.reload()">Bosh Sahifa</button>
            `;
        }

        // Testni qayta boshlash
        function restartTest() {
            currentQuestions = shuffleArray([...allQuestions]).slice(0, 50);
            document.getElementById('result').innerHTML = '';
            startTest();
        }

        // Boshlash tugmasi
        document.getElementById('startBtn').addEventListener('click', initTest);
    </script>
</body>
</html>
